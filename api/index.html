<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta property="og:type" content="article"><meta property="og:url" content="http://postcss.org/"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@postcss"><meta name="twitter:creator" content="@postcss"><meta name="description" content="Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins."><link rel="icon" type="image/x-icon" sizes="any" href="/api/assets/favicon-DbGqNhKa.ico"><link rel="icon" href="/api/assets/logo-C2ryQugb.svg" type="image/svg+xml"><meta property="og:image" content="./base/og.jpg"><title>PostCSS API</title>  <script type="module" crossorigin src="/api/assets/api-tl_tE5Qn.js"></script>
  <link rel="stylesheet" crossorigin href="/api/assets/api-hQTQJUj-.css">
</head><body><main><div class="hero is-small"><a class="hero_home" rel="home" href="/"><img class="hero_logo" src="/api/assets/postcss-CsElRNOW.svg" alt="PostCSS logo"></a></div><nav class="nav"><ul class="nav_items"><li class="nav_item"><a class="nav_link" href="https://github.com/postcss/postcss#usage">Setup</a></li><li class="nav_item"><a class="nav_link" href="/docs/">Docs</a></li><li class="nav_item"><a class="nav_link" href="/docs/postcss-plugins">Plugins</a></li><li class="nav_item"><a class="nav_link" href="/api/">API</a></li><li class="nav_item"><a class="nav_link" href="https://github.com/postcss/brand">Logo</a></li></ul></nav><nav class="sidemenu"><ul><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#atrule" class="sidemenu_section">AtRule</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#atrule-nodes" class="sidemenu_child">nodes</a></li><li><a href="#atrule-parent" class="sidemenu_child">parent</a></li><li><a href="#atrule-raws" class="sidemenu_child">raws</a></li><li><a href="#atrule-source" class="sidemenu_child">source</a></li><li><a href="#atrule-type" class="sidemenu_child">type</a></li><li><a href="#atrule-first" class="sidemenu_child">first</a></li><li><a href="#atrule-last" class="sidemenu_child">last</a></li><li><a href="#atrule-name" class="sidemenu_child">name</a></li><li><a href="#atrule-params" class="sidemenu_child">params</a></li><li><a href="#atrule-after" class="sidemenu_child">after()</a></li><li><a href="#atrule-append" class="sidemenu_child">append()</a></li><li><a href="#atrule-assign" class="sidemenu_child">assign()</a></li><li><a href="#atrule-before" class="sidemenu_child">before()</a></li><li><a href="#atrule-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#atrule-clone" class="sidemenu_child">clone()</a></li><li><a href="#atrule-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#atrule-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#atrule-each" class="sidemenu_child">each()</a></li><li><a href="#atrule-error" class="sidemenu_child">error()</a></li><li><a href="#atrule-every" class="sidemenu_child">every()</a></li><li><a href="#atrule-index" class="sidemenu_child">index()</a></li><li><a href="#atrule-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#atrule-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#atrule-markdirty" class="sidemenu_child">markDirty()</a></li><li><a href="#atrule-next" class="sidemenu_child">next()</a></li><li><a href="#atrule-positionby" class="sidemenu_child">positionBy()</a></li><li><a href="#atrule-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#atrule-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#atrule-prev" class="sidemenu_child">prev()</a></li><li><a href="#atrule-push" class="sidemenu_child">push()</a></li><li><a href="#atrule-rangeby" class="sidemenu_child">rangeBy()</a></li><li><a href="#atrule-raw" class="sidemenu_child">raw()</a></li><li><a href="#atrule-remove" class="sidemenu_child">remove()</a></li><li><a href="#atrule-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#atrule-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#atrule-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#atrule-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#atrule-root" class="sidemenu_child">root()</a></li><li><a href="#atrule-some" class="sidemenu_child">some()</a></li><li><a href="#atrule-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#atrule-tostring" class="sidemenu_child">toString()</a></li><li><a href="#atrule-walk" class="sidemenu_child">walk()</a></li><li><a href="#atrule-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#atrule-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#atrule-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#atrule-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#atrule-warn" class="sidemenu_child">warn()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#comment" class="sidemenu_section">Comment</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#comment-parent" class="sidemenu_child">parent</a></li><li><a href="#comment-raws" class="sidemenu_child">raws</a></li><li><a href="#comment-source" class="sidemenu_child">source</a></li><li><a href="#comment-type" class="sidemenu_child">type</a></li><li><a href="#comment-text" class="sidemenu_child">text</a></li><li><a href="#comment-after" class="sidemenu_child">after()</a></li><li><a href="#comment-assign" class="sidemenu_child">assign()</a></li><li><a href="#comment-before" class="sidemenu_child">before()</a></li><li><a href="#comment-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#comment-clone" class="sidemenu_child">clone()</a></li><li><a href="#comment-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#comment-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#comment-error" class="sidemenu_child">error()</a></li><li><a href="#comment-markdirty" class="sidemenu_child">markDirty()</a></li><li><a href="#comment-next" class="sidemenu_child">next()</a></li><li><a href="#comment-positionby" class="sidemenu_child">positionBy()</a></li><li><a href="#comment-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#comment-prev" class="sidemenu_child">prev()</a></li><li><a href="#comment-rangeby" class="sidemenu_child">rangeBy()</a></li><li><a href="#comment-raw" class="sidemenu_child">raw()</a></li><li><a href="#comment-remove" class="sidemenu_child">remove()</a></li><li><a href="#comment-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#comment-root" class="sidemenu_child">root()</a></li><li><a href="#comment-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#comment-tostring" class="sidemenu_child">toString()</a></li><li><a href="#comment-warn" class="sidemenu_child">warn()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#csssyntaxerror" class="sidemenu_section">CssSyntaxError</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#csssyntaxerror-column" class="sidemenu_child">column</a></li><li><a href="#csssyntaxerror-endcolumn" class="sidemenu_child">endColumn</a></li><li><a href="#csssyntaxerror-endline" class="sidemenu_child">endLine</a></li><li><a href="#csssyntaxerror-file" class="sidemenu_child">file</a></li><li><a href="#csssyntaxerror-input" class="sidemenu_child">input</a></li><li><a href="#csssyntaxerror-line" class="sidemenu_child">line</a></li><li><a href="#csssyntaxerror-message" class="sidemenu_child">message</a></li><li><a href="#csssyntaxerror-name" class="sidemenu_child">name</a></li><li><a href="#csssyntaxerror-plugin" class="sidemenu_child">plugin</a></li><li><a href="#csssyntaxerror-reason" class="sidemenu_child">reason</a></li><li><a href="#csssyntaxerror-source" class="sidemenu_child">source</a></li><li><a href="#csssyntaxerror-stack" class="sidemenu_child">stack</a></li><li><a href="#csssyntaxerror-preparestacktrace" class="sidemenu_child">prepareStackTrace</a></li><li><a href="#csssyntaxerror-stacktracelimit" class="sidemenu_child">stackTraceLimit</a></li><li><a href="#csssyntaxerror-showsourcecode" class="sidemenu_child">showSourceCode()</a></li><li><a href="#csssyntaxerror-tostring" class="sidemenu_child">toString()</a></li><li><a href="#csssyntaxerror-capturestacktrace" class="sidemenu_child">captureStackTrace()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#declaration" class="sidemenu_section">Declaration</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#declaration-parent" class="sidemenu_child">parent</a></li><li><a href="#declaration-raws" class="sidemenu_child">raws</a></li><li><a href="#declaration-source" class="sidemenu_child">source</a></li><li><a href="#declaration-type" class="sidemenu_child">type</a></li><li><a href="#declaration-important" class="sidemenu_child">important</a></li><li><a href="#declaration-prop" class="sidemenu_child">prop</a></li><li><a href="#declaration-value" class="sidemenu_child">value</a></li><li><a href="#declaration-variable" class="sidemenu_child">variable</a></li><li><a href="#declaration-after" class="sidemenu_child">after()</a></li><li><a href="#declaration-assign" class="sidemenu_child">assign()</a></li><li><a href="#declaration-before" class="sidemenu_child">before()</a></li><li><a href="#declaration-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#declaration-clone" class="sidemenu_child">clone()</a></li><li><a href="#declaration-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#declaration-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#declaration-error" class="sidemenu_child">error()</a></li><li><a href="#declaration-markdirty" class="sidemenu_child">markDirty()</a></li><li><a href="#declaration-next" class="sidemenu_child">next()</a></li><li><a href="#declaration-positionby" class="sidemenu_child">positionBy()</a></li><li><a href="#declaration-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#declaration-prev" class="sidemenu_child">prev()</a></li><li><a href="#declaration-rangeby" class="sidemenu_child">rangeBy()</a></li><li><a href="#declaration-raw" class="sidemenu_child">raw()</a></li><li><a href="#declaration-remove" class="sidemenu_child">remove()</a></li><li><a href="#declaration-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#declaration-root" class="sidemenu_child">root()</a></li><li><a href="#declaration-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#declaration-tostring" class="sidemenu_child">toString()</a></li><li><a href="#declaration-warn" class="sidemenu_child">warn()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#document" class="sidemenu_section">Document</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#document-nodes" class="sidemenu_child">nodes</a></li><li><a href="#document-parent" class="sidemenu_child">parent</a></li><li><a href="#document-raws" class="sidemenu_child">raws</a></li><li><a href="#document-source" class="sidemenu_child">source</a></li><li><a href="#document-type" class="sidemenu_child">type</a></li><li><a href="#document-first" class="sidemenu_child">first</a></li><li><a href="#document-last" class="sidemenu_child">last</a></li><li><a href="#document-after" class="sidemenu_child">after()</a></li><li><a href="#document-append" class="sidemenu_child">append()</a></li><li><a href="#document-assign" class="sidemenu_child">assign()</a></li><li><a href="#document-before" class="sidemenu_child">before()</a></li><li><a href="#document-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#document-clone" class="sidemenu_child">clone()</a></li><li><a href="#document-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#document-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#document-each" class="sidemenu_child">each()</a></li><li><a href="#document-error" class="sidemenu_child">error()</a></li><li><a href="#document-every" class="sidemenu_child">every()</a></li><li><a href="#document-index" class="sidemenu_child">index()</a></li><li><a href="#document-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#document-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#document-markdirty" class="sidemenu_child">markDirty()</a></li><li><a href="#document-next" class="sidemenu_child">next()</a></li><li><a href="#document-positionby" class="sidemenu_child">positionBy()</a></li><li><a href="#document-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#document-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#document-prev" class="sidemenu_child">prev()</a></li><li><a href="#document-push" class="sidemenu_child">push()</a></li><li><a href="#document-rangeby" class="sidemenu_child">rangeBy()</a></li><li><a href="#document-raw" class="sidemenu_child">raw()</a></li><li><a href="#document-remove" class="sidemenu_child">remove()</a></li><li><a href="#document-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#document-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#document-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#document-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#document-root" class="sidemenu_child">root()</a></li><li><a href="#document-some" class="sidemenu_child">some()</a></li><li><a href="#document-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#document-toresult" class="sidemenu_child">toResult()</a></li><li><a href="#document-tostring" class="sidemenu_child">toString()</a></li><li><a href="#document-walk" class="sidemenu_child">walk()</a></li><li><a href="#document-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#document-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#document-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#document-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#document-warn" class="sidemenu_child">warn()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#input" class="sidemenu_section">Input</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#input-css" class="sidemenu_child">css</a></li><li><a href="#input-document" class="sidemenu_child">document</a></li><li><a href="#input-file" class="sidemenu_child">file</a></li><li><a href="#input-hasbom" class="sidemenu_child">hasBOM</a></li><li><a href="#input-id" class="sidemenu_child">id</a></li><li><a href="#input-map" class="sidemenu_child">map</a></li><li><a href="#input-from" class="sidemenu_child">from</a></li><li><a href="#input-error" class="sidemenu_child">error()</a></li><li><a href="#input-fromlineandcolumn" class="sidemenu_child">fromLineAndColumn()</a></li><li><a href="#input-fromoffset" class="sidemenu_child">fromOffset()</a></li><li><a href="#input-origin" class="sidemenu_child">origin()</a></li><li><a href="#input-tojson" class="sidemenu_child">toJSON()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#noworkresult" class="sidemenu_section">NoWorkResult</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#noworkresult-catch" class="sidemenu_child">catch</a></li><li><a href="#noworkresult-finally" class="sidemenu_child">finally</a></li><li><a href="#noworkresult-then" class="sidemenu_child">then</a></li><li><a href="#noworkresult-[tostringtag]" class="sidemenu_child">[toStringTag]</a></li><li><a href="#noworkresult-content" class="sidemenu_child">content</a></li><li><a href="#noworkresult-css" class="sidemenu_child">css</a></li><li><a href="#noworkresult-map" class="sidemenu_child">map</a></li><li><a href="#noworkresult-messages" class="sidemenu_child">messages</a></li><li><a href="#noworkresult-opts" class="sidemenu_child">opts</a></li><li><a href="#noworkresult-processor" class="sidemenu_child">processor</a></li><li><a href="#noworkresult-root" class="sidemenu_child">root</a></li><li><a href="#noworkresult-async" class="sidemenu_child">async()</a></li><li><a href="#noworkresult-sync" class="sidemenu_child">sync()</a></li><li><a href="#noworkresult-tostring" class="sidemenu_child">toString()</a></li><li><a href="#noworkresult-warnings" class="sidemenu_child">warnings()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#previousmap" class="sidemenu_section">PreviousMap</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#previousmap-annotation" class="sidemenu_child">annotation</a></li><li><a href="#previousmap-file" class="sidemenu_child">file</a></li><li><a href="#previousmap-inline" class="sidemenu_child">inline</a></li><li><a href="#previousmap-mapfile" class="sidemenu_child">mapFile</a></li><li><a href="#previousmap-root" class="sidemenu_child">root</a></li><li><a href="#previousmap-text" class="sidemenu_child">text</a></li><li><a href="#previousmap-consumer" class="sidemenu_child">consumer()</a></li><li><a href="#previousmap-withcontent" class="sidemenu_child">withContent()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#result" class="sidemenu_section">Result</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#result-css" class="sidemenu_child">css</a></li><li><a href="#result-lastplugin" class="sidemenu_child">lastPlugin</a></li><li><a href="#result-map" class="sidemenu_child">map</a></li><li><a href="#result-messages" class="sidemenu_child">messages</a></li><li><a href="#result-opts" class="sidemenu_child">opts</a></li><li><a href="#result-processor" class="sidemenu_child">processor</a></li><li><a href="#result-root" class="sidemenu_child">root</a></li><li><a href="#result-content" class="sidemenu_child">content</a></li><li><a href="#result-tostring" class="sidemenu_child">toString()</a></li><li><a href="#result-warn" class="sidemenu_child">warn()</a></li><li><a href="#result-warnings" class="sidemenu_child">warnings()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#root" class="sidemenu_section">Root</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#root-nodes" class="sidemenu_child">nodes</a></li><li><a href="#root-parent" class="sidemenu_child">parent</a></li><li><a href="#root-raws" class="sidemenu_child">raws</a></li><li><a href="#root-source" class="sidemenu_child">source</a></li><li><a href="#root-type" class="sidemenu_child">type</a></li><li><a href="#root-first" class="sidemenu_child">first</a></li><li><a href="#root-last" class="sidemenu_child">last</a></li><li><a href="#root-after" class="sidemenu_child">after()</a></li><li><a href="#root-append" class="sidemenu_child">append()</a></li><li><a href="#root-assign" class="sidemenu_child">assign()</a></li><li><a href="#root-before" class="sidemenu_child">before()</a></li><li><a href="#root-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#root-clone" class="sidemenu_child">clone()</a></li><li><a href="#root-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#root-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#root-each" class="sidemenu_child">each()</a></li><li><a href="#root-error" class="sidemenu_child">error()</a></li><li><a href="#root-every" class="sidemenu_child">every()</a></li><li><a href="#root-index" class="sidemenu_child">index()</a></li><li><a href="#root-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#root-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#root-markdirty" class="sidemenu_child">markDirty()</a></li><li><a href="#root-next" class="sidemenu_child">next()</a></li><li><a href="#root-positionby" class="sidemenu_child">positionBy()</a></li><li><a href="#root-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#root-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#root-prev" class="sidemenu_child">prev()</a></li><li><a href="#root-push" class="sidemenu_child">push()</a></li><li><a href="#root-rangeby" class="sidemenu_child">rangeBy()</a></li><li><a href="#root-raw" class="sidemenu_child">raw()</a></li><li><a href="#root-remove" class="sidemenu_child">remove()</a></li><li><a href="#root-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#root-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#root-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#root-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#root-root" class="sidemenu_child">root()</a></li><li><a href="#root-some" class="sidemenu_child">some()</a></li><li><a href="#root-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#root-toresult" class="sidemenu_child">toResult()</a></li><li><a href="#root-tostring" class="sidemenu_child">toString()</a></li><li><a href="#root-walk" class="sidemenu_child">walk()</a></li><li><a href="#root-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#root-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#root-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#root-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#root-warn" class="sidemenu_child">warn()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#rule" class="sidemenu_section">Rule</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#rule-nodes" class="sidemenu_child">nodes</a></li><li><a href="#rule-parent" class="sidemenu_child">parent</a></li><li><a href="#rule-raws" class="sidemenu_child">raws</a></li><li><a href="#rule-source" class="sidemenu_child">source</a></li><li><a href="#rule-type" class="sidemenu_child">type</a></li><li><a href="#rule-first" class="sidemenu_child">first</a></li><li><a href="#rule-last" class="sidemenu_child">last</a></li><li><a href="#rule-selector" class="sidemenu_child">selector</a></li><li><a href="#rule-selectors" class="sidemenu_child">selectors</a></li><li><a href="#rule-after" class="sidemenu_child">after()</a></li><li><a href="#rule-append" class="sidemenu_child">append()</a></li><li><a href="#rule-assign" class="sidemenu_child">assign()</a></li><li><a href="#rule-before" class="sidemenu_child">before()</a></li><li><a href="#rule-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#rule-clone" class="sidemenu_child">clone()</a></li><li><a href="#rule-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#rule-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#rule-each" class="sidemenu_child">each()</a></li><li><a href="#rule-error" class="sidemenu_child">error()</a></li><li><a href="#rule-every" class="sidemenu_child">every()</a></li><li><a href="#rule-index" class="sidemenu_child">index()</a></li><li><a href="#rule-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#rule-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#rule-markdirty" class="sidemenu_child">markDirty()</a></li><li><a href="#rule-next" class="sidemenu_child">next()</a></li><li><a href="#rule-positionby" class="sidemenu_child">positionBy()</a></li><li><a href="#rule-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#rule-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#rule-prev" class="sidemenu_child">prev()</a></li><li><a href="#rule-push" class="sidemenu_child">push()</a></li><li><a href="#rule-rangeby" class="sidemenu_child">rangeBy()</a></li><li><a href="#rule-raw" class="sidemenu_child">raw()</a></li><li><a href="#rule-remove" class="sidemenu_child">remove()</a></li><li><a href="#rule-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#rule-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#rule-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#rule-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#rule-root" class="sidemenu_child">root()</a></li><li><a href="#rule-some" class="sidemenu_child">some()</a></li><li><a href="#rule-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#rule-tostring" class="sidemenu_child">toString()</a></li><li><a href="#rule-walk" class="sidemenu_child">walk()</a></li><li><a href="#rule-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#rule-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#rule-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#rule-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#rule-warn" class="sidemenu_child">warn()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#stringifier" class="sidemenu_section">Stringifier</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#stringifier-builder" class="sidemenu_child">builder</a></li><li><a href="#stringifier-atrule" class="sidemenu_child">atrule()</a></li><li><a href="#stringifier-beforeafter" class="sidemenu_child">beforeAfter()</a></li><li><a href="#stringifier-block" class="sidemenu_child">block()</a></li><li><a href="#stringifier-body" class="sidemenu_child">body()</a></li><li><a href="#stringifier-comment" class="sidemenu_child">comment()</a></li><li><a href="#stringifier-decl" class="sidemenu_child">decl()</a></li><li><a href="#stringifier-document" class="sidemenu_child">document()</a></li><li><a href="#stringifier-raw" class="sidemenu_child">raw()</a></li><li><a href="#stringifier-rawbeforeclose" class="sidemenu_child">rawBeforeClose()</a></li><li><a href="#stringifier-rawbeforecomment" class="sidemenu_child">rawBeforeComment()</a></li><li><a href="#stringifier-rawbeforedecl" class="sidemenu_child">rawBeforeDecl()</a></li><li><a href="#stringifier-rawbeforeopen" class="sidemenu_child">rawBeforeOpen()</a></li><li><a href="#stringifier-rawbeforerule" class="sidemenu_child">rawBeforeRule()</a></li><li><a href="#stringifier-rawcolon" class="sidemenu_child">rawColon()</a></li><li><a href="#stringifier-rawemptybody" class="sidemenu_child">rawEmptyBody()</a></li><li><a href="#stringifier-rawindent" class="sidemenu_child">rawIndent()</a></li><li><a href="#stringifier-rawsemicolon" class="sidemenu_child">rawSemicolon()</a></li><li><a href="#stringifier-rawvalue" class="sidemenu_child">rawValue()</a></li><li><a href="#stringifier-root" class="sidemenu_child">root()</a></li><li><a href="#stringifier-rule" class="sidemenu_child">rule()</a></li><li><a href="#stringifier-stringify" class="sidemenu_child">stringify()</a></li></ul></li><li class="sidemenu_item"><div class="sidemenu_bar"><a href="#warning" class="sidemenu_section">Warning</a><button class="sidemenu_controller"></button></div><ul class="sidemenu_children"><li><a href="#warning-column" class="sidemenu_child">column</a></li><li><a href="#warning-endcolumn" class="sidemenu_child">endColumn</a></li><li><a href="#warning-endline" class="sidemenu_child">endLine</a></li><li><a href="#warning-line" class="sidemenu_child">line</a></li><li><a href="#warning-node" class="sidemenu_child">node</a></li><li><a href="#warning-plugin" class="sidemenu_child">plugin</a></li><li><a href="#warning-text" class="sidemenu_child">text</a></li><li><a href="#warning-type" class="sidemenu_child">type</a></li><li><a href="#warning-tostring" class="sidemenu_child">toString()</a></li></ul></li></ul></nav><section class="doc"><h1 id="postcss" class="doc_title">postcss</h1><p>Create a new <code><a href="#processor">Processor</a></code> instance that will apply <code>plugins</code>
as CSS processors.</p>
<pre><code class="code language-js"><span class="code-keyword">let</span> postcss = <span class="code-built_in">require</span>(<span class="code-string">'postcss'</span>)

<span class="code-title function_">postcss</span>(plugins).<span class="code-title function_">process</span>(css, { <span class="code-keyword">from</span>, to }).<span class="code-title function_">then</span>(<span class="code-function"><span class="code-params">result</span> =></span> {
  <span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(result.<span class="code-property">css</span>)
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>plugins</code></td><td>readonly <a href="#acceptedplugin">AcceptedPlugin</a>[]</td><td>PostCSS plugins.</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>plugins…</code></td><td><a href="#acceptedplugin">AcceptedPlugin</a>[]</td><td>PostCSS plugins.</td></tr></table><p>Returns <code><a href="#processor">Processor</a></code>. </p><h2 id="postcss-acceptedplugin" class="doc_subtitle"><span class="doc_prefix">postcss.</span>AcceptedPlugin</h2><p>Type: Object | <a href="#oldplugin">OldPlugin</a>&lt;any> | <a href="#plugin">Plugin</a> | <a href="#plugincreator">PluginCreator</a>&lt;any> | <a href="#processor">Processor</a> | <a href="#transformcallback">TransformCallback</a>.</p><h2 id="postcss-builder" class="doc_subtitle"><span class="doc_prefix">postcss.</span>Builder</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>part</code></td><td>string</td></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>type</code></td><td>"end" | "start"</td></tr></table><h2 id="postcss-helpers" class="doc_subtitle"><span class="doc_prefix">postcss.</span>Helpers</h2><p>Type: Object &amp; <a href="#postcss">Postcss</a>.</p><h2 id="postcss-jsonhydrator" class="doc_subtitle"><span class="doc_prefix">postcss.</span>JSONHydrator</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object[]</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="postcss-oldplugin" class="doc_subtitle"><span class="doc_prefix">postcss.</span>OldPlugin</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>opts</code></td><td>T</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td></tr></table><p>Returns <code><a href="#transformer">Transformer</a></code>. </p><h2 id="postcss-parser" class="doc_subtitle"><span class="doc_prefix">postcss.</span>Parser</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>css</code></td><td>string | Object</td></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#processoptions">ProcessOptions</a>&lt;Document_ | <a href="#root">Root</a>>, "map" | "document" | "from"></td></tr></table><p>Returns <code>RootNode</code>. </p><h2 id="postcss-plugincreator" class="doc_subtitle"><span class="doc_prefix">postcss.</span>PluginCreator</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>opts</code></td><td>PluginOptions</td></tr></table><p>Returns <code><a href="#processor">Processor</a> | <a href="#plugin">Plugin</a></code>. </p><h2 id="postcss-postcss" class="doc_subtitle"><span class="doc_prefix">postcss.</span>Postcss</h2><p>Type: typeof postcss.</p><h2 id="postcss-ruleprops" class="doc_subtitle"><span class="doc_prefix">postcss.</span>RuleProps</h2><p>Type: Object &amp; (Object | Object) &amp; <a href="#containerprops">ContainerProps</a>.</p><h2 id="postcss-sourcemap" class="doc_subtitle"><span class="doc_prefix">postcss.</span>SourceMap</h2><p>Type: Object &amp; SourceMapGenerator.</p><h2 id="postcss-stringifier" class="doc_subtitle"><span class="doc_prefix">postcss.</span>Stringifier</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>builder</code></td><td><a href="#builder">Builder</a></td></tr></table><h2 id="postcss-transformcallback" class="doc_subtitle"><span class="doc_prefix">postcss.</span>TransformCallback</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td></tr></table><p>Returns <code>void | Promise&lt;void></code>. </p><h2 id="postcss-transformer" class="doc_subtitle"><span class="doc_prefix">postcss.</span>Transformer</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td></tr></table><p>Returns <code>void | Promise&lt;void></code>. </p><h2 id="postcss-atrule" class="doc_subtitle"><span class="doc_prefix">postcss.</span>atRule</h2><p>Creates a new <code><a href="#atrule">AtRule</a></code> node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>defaults</code></td><td><a href="#atruleprops">AtRuleProps</a></td><td>Properties for the new node.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="postcss-comment" class="doc_subtitle"><span class="doc_prefix">postcss.</span>comment</h2><p>Creates a new <code><a href="#comment">Comment</a></code> node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>defaults</code></td><td><a href="#commentprops">CommentProps</a></td><td>Properties for the new node.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="postcss-decl" class="doc_subtitle"><span class="doc_prefix">postcss.</span>decl</h2><p>Creates a new <code><a href="#declaration">Declaration</a></code> node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>defaults</code></td><td><a href="#declarationprops">DeclarationProps</a></td><td>Properties for the new node.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="postcss-document" class="doc_subtitle"><span class="doc_prefix">postcss.</span>document</h2><p>Creates a new <code><a href="#document">Document</a></code> node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>defaults</code></td><td><a href="#documentprops">DocumentProps</a></td><td>Properties for the new node.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="postcss-fromjson" class="doc_subtitle"><span class="doc_prefix">postcss.</span>fromJSON</h2><p>Rehydrate a JSON AST (from <code><a href="#node-tojson">Node#toJSON</a></code>) back into the AST classes.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> json = root.<span class="code-title function_">toJSON</span>()
<span class="code-comment">// save to file, send by network, etc</span>
<span class="code-keyword">const</span> root2  = postcss.<span class="code-title function_">fromJSON</span>(json)
</code></pre><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object[]</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="postcss-list" class="doc_subtitle"><span class="doc_prefix">postcss.</span>list</h2><p>Type: <a href="#list">List</a>.</p><h2 id="postcss-parse" class="doc_subtitle"><span class="doc_prefix">postcss.</span>parse</h2><p>Parses source css and returns a new <code><a href="#root">Root</a></code> or <code><a href="#document">Document</a></code> node,
which contains the source CSS nodes.</p>
<pre><code class="code language-js"><span class="code-comment">// Simple CSS concatenation with source map support</span>
<span class="code-keyword">const</span> root1 = postcss.<span class="code-title function_">parse</span>(css1, { <span class="code-attr">from</span>: file1 })
<span class="code-keyword">const</span> root2 = postcss.<span class="code-title function_">parse</span>(css2, { <span class="code-attr">from</span>: file2 })
root1.<span class="code-title function_">append</span>(root2).<span class="code-title function_">toResult</span>().<span class="code-property">css</span>
</code></pre><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>css</code></td><td>string | Object</td></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#processoptions">ProcessOptions</a>&lt;Document_ | <a href="#root">Root</a>>, "map" | "document" | "from"></td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="postcss-root" class="doc_subtitle"><span class="doc_prefix">postcss.</span>root</h2><p>Creates a new <code><a href="#root">Root</a></code> node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>defaults</code></td><td><a href="#rootprops">RootProps</a></td><td>Properties for the new node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="postcss-rule" class="doc_subtitle"><span class="doc_prefix">postcss.</span>rule</h2><p>Creates a new <code><a href="#rule">Rule</a></code> node.</p><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>defaults</code></td><td><a href="#ruleprops">RuleProps</a></td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="postcss-stringify" class="doc_subtitle"><span class="doc_prefix">postcss.</span>stringify</h2><p>Default function to convert a node tree into a CSS string.</p><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>builder</code></td><td><a href="#builder">Builder</a></td></tr></table></section><section class="doc"><h1 id="atrule" class="doc_title">AtRule</h1><p>Represents an at-rule.</p>
<pre><code class="code language-js"><span class="code-title class_">Once</span> (root, { <span class="code-title class_">AtRule</span> }) {
  <span class="code-keyword">let</span> media = <span class="code-keyword">new</span> <span class="code-title class_">AtRule</span>({ <span class="code-attr">name</span>: <span class="code-string">'media'</span>, <span class="code-attr">params</span>: <span class="code-string">'print'</span> })
  media.<span class="code-title function_">append</span>(…)
  root.<span class="code-title function_">append</span>(media)
}
</code></pre>
<p>If it’s followed in the CSS by a <code>{}</code> block, this node will have
a nodes property representing its children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'@charset "UTF-8"; @media print {}'</span>)

<span class="code-keyword">const</span> charset = root.<span class="code-property">first</span>
charset.<span class="code-property">type</span>  <span class="code-comment">//=> 'atrule'</span>
charset.<span class="code-property">nodes</span> <span class="code-comment">//=> undefined</span>

<span class="code-keyword">const</span> media = root.<span class="code-property">last</span>
media.<span class="code-property">nodes</span>   <span class="code-comment">//=> []</span>
</code></pre><h2 id="atrule-after" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-append" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-assign" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#atruleprops">AtRuleProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-before" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-cleanraws" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="atrule-clone" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-cloneafter" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-clonebefore" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-each" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="atrule-error" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="atrule-every" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="atrule-index" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="atrule-insertafter" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-insertbefore" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-markdirty" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="atrule-next" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="atrule-nodes" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>nodes</h2><p>An array containing the layer’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'@layer example { a { color: black } }'</span>)
<span class="code-keyword">const</span> layer = root.<span class="code-property">first</span>
layer.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
layer.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
</code></pre>
<p>Can be <code>undefinded</code> if the at-rule has no body.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'@layer a, b, c;'</span>)
<span class="code-keyword">const</span> layer = root.<span class="code-property">first</span>
layer.<span class="code-property">nodes</span> <span class="code-comment">//=> undefined</span>
</code></pre><p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="atrule-parent" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: <a href="#containerwithchildren">ContainerWithChildren</a>.</p><h2 id="atrule-positionby" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="atrule-positioninside" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="atrule-prepend" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-prev" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="atrule-push" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-rangeby" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="atrule-raw" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="atrule-raws" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#atruleraws">AtRuleRaws</a>.</p><h2 id="atrule-remove" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-removeall" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-removechild" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-replacevalues" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-replacewith" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#atrule">AtRule</a></code>. </p><h2 id="atrule-root" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="atrule-some" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="atrule-source" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="atrule-tojson" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="atrule-tostring" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="atrule-type" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "atrule".</p><h2 id="atrule-walk" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="atrule-walkatrules" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="atrule-walkcomments" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="atrule-walkdecls" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="atrule-walkrules" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="atrule-warn" class="doc_subtitle"><span class="doc_prefix">AtRule#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="comment" class="doc_title">Comment</h1><p>It represents a class that handles
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Comments">CSS comments</a></p>
<pre><code class="code language-js"><span class="code-title class_">Once</span> (root, { <span class="code-title class_">Comment</span> }) {
  <span class="code-keyword">const</span> note = <span class="code-keyword">new</span> <span class="code-title class_">Comment</span>({ <span class="code-attr">text</span>: <span class="code-string">'Note: …'</span> })
  root.<span class="code-title function_">append</span>(note)
}
</code></pre>
<p>Remember that CSS comments inside selectors, at-rule parameters,
or declaration values will be stored in the <code>raws</code> properties
explained above.</p><h2 id="comment-after" class="doc_subtitle"><span class="doc_prefix">Comment#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-assign" class="doc_subtitle"><span class="doc_prefix">Comment#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#commentprops">CommentProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-before" class="doc_subtitle"><span class="doc_prefix">Comment#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-cleanraws" class="doc_subtitle"><span class="doc_prefix">Comment#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="comment-clone" class="doc_subtitle"><span class="doc_prefix">Comment#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-cloneafter" class="doc_subtitle"><span class="doc_prefix">Comment#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-clonebefore" class="doc_subtitle"><span class="doc_prefix">Comment#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-error" class="doc_subtitle"><span class="doc_prefix">Comment#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="comment-markdirty" class="doc_subtitle"><span class="doc_prefix">Comment#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="comment-next" class="doc_subtitle"><span class="doc_prefix">Comment#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="comment-parent" class="doc_subtitle"><span class="doc_prefix">Comment#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Container_&lt;<a href="#childnode">ChildNode</a>>.</p><h2 id="comment-positionby" class="doc_subtitle"><span class="doc_prefix">Comment#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="comment-positioninside" class="doc_subtitle"><span class="doc_prefix">Comment#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="comment-prev" class="doc_subtitle"><span class="doc_prefix">Comment#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="comment-rangeby" class="doc_subtitle"><span class="doc_prefix">Comment#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="comment-raw" class="doc_subtitle"><span class="doc_prefix">Comment#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="comment-raws" class="doc_subtitle"><span class="doc_prefix">Comment#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#commentraws">CommentRaws</a>.</p><h2 id="comment-remove" class="doc_subtitle"><span class="doc_prefix">Comment#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-replacewith" class="doc_subtitle"><span class="doc_prefix">Comment#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#comment">Comment</a></code>. </p><h2 id="comment-root" class="doc_subtitle"><span class="doc_prefix">Comment#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="comment-source" class="doc_subtitle"><span class="doc_prefix">Comment#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="comment-tojson" class="doc_subtitle"><span class="doc_prefix">Comment#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="comment-tostring" class="doc_subtitle"><span class="doc_prefix">Comment#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="comment-type" class="doc_subtitle"><span class="doc_prefix">Comment#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "comment".</p><h2 id="comment-warn" class="doc_subtitle"><span class="doc_prefix">Comment#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="container" class="doc_title">Container</h1><p>The <code><a href="#root">Root</a></code>, <code><a href="#atrule">AtRule</a></code>, and <code><a href="#rule">Rule</a></code> container nodes
inherit some common methods to help work with their children.</p>
<p>Note that all containers can store any content. If you write a rule inside
a rule, PostCSS will parse it.</p><h2 id="container-after" class="doc_subtitle"><span class="doc_prefix">Container#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-append" class="doc_subtitle"><span class="doc_prefix">Container#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-assign" class="doc_subtitle"><span class="doc_prefix">Container#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#containerprops">ContainerProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-before" class="doc_subtitle"><span class="doc_prefix">Container#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-cleanraws" class="doc_subtitle"><span class="doc_prefix">Container#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="container-clone" class="doc_subtitle"><span class="doc_prefix">Container#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#containerprops">ContainerProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-cloneafter" class="doc_subtitle"><span class="doc_prefix">Container#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#containerprops">ContainerProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-clonebefore" class="doc_subtitle"><span class="doc_prefix">Container#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#containerprops">ContainerProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-each" class="doc_subtitle"><span class="doc_prefix">Container#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-error" class="doc_subtitle"><span class="doc_prefix">Container#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="container-every" class="doc_subtitle"><span class="doc_prefix">Container#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="container-index" class="doc_subtitle"><span class="doc_prefix">Container#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | Child</td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="container-insertafter" class="doc_subtitle"><span class="doc_prefix">Container#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | Child</td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-insertbefore" class="doc_subtitle"><span class="doc_prefix">Container#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | Child</td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-markdirty" class="doc_subtitle"><span class="doc_prefix">Container#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="container-next" class="doc_subtitle"><span class="doc_prefix">Container#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="container-nodes" class="doc_subtitle"><span class="doc_prefix">Container#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: Child[].</p><h2 id="container-parent" class="doc_subtitle"><span class="doc_prefix">Container#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Container_&lt;<a href="#childnode">ChildNode</a>> | Document_.</p><h2 id="container-positionby" class="doc_subtitle"><span class="doc_prefix">Container#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="container-positioninside" class="doc_subtitle"><span class="doc_prefix">Container#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="container-prepend" class="doc_subtitle"><span class="doc_prefix">Container#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-prev" class="doc_subtitle"><span class="doc_prefix">Container#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="container-push" class="doc_subtitle"><span class="doc_prefix">Container#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>Child</td><td>New node.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-rangeby" class="doc_subtitle"><span class="doc_prefix">Container#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="container-raw" class="doc_subtitle"><span class="doc_prefix">Container#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="container-raws" class="doc_subtitle"><span class="doc_prefix">Container#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: any.</p><h2 id="container-remove" class="doc_subtitle"><span class="doc_prefix">Container#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-removeall" class="doc_subtitle"><span class="doc_prefix">Container#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-removechild" class="doc_subtitle"><span class="doc_prefix">Container#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | Child</td><td>Child or child’s index.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-replacevalues" class="doc_subtitle"><span class="doc_prefix">Container#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-replacewith" class="doc_subtitle"><span class="doc_prefix">Container#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#container">Container</a>&lt;Child></code>. </p><h2 id="container-root" class="doc_subtitle"><span class="doc_prefix">Container#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="container-some" class="doc_subtitle"><span class="doc_prefix">Container#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="container-source" class="doc_subtitle"><span class="doc_prefix">Container#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="container-tojson" class="doc_subtitle"><span class="doc_prefix">Container#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="container-tostring" class="doc_subtitle"><span class="doc_prefix">Container#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="container-type" class="doc_subtitle"><span class="doc_prefix">Container#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: string.</p><h2 id="container-walk" class="doc_subtitle"><span class="doc_prefix">Container#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkatrules" class="doc_subtitle"><span class="doc_prefix">Container#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkcomments" class="doc_subtitle"><span class="doc_prefix">Container#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkdecls" class="doc_subtitle"><span class="doc_prefix">Container#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkrules" class="doc_subtitle"><span class="doc_prefix">Container#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-warn" class="doc_subtitle"><span class="doc_prefix">Container#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="csssyntaxerror" class="doc_title">CssSyntaxError</h1><p>The CSS parser throws this error for broken CSS.</p>
<p>Custom parsers can throw this error for broken custom syntax using
the <code><a href="#node-error">Node#error</a></code> method.</p>
<p>PostCSS will use the input source map to detect the original error location.
If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
PostCSS will show the original position in the Sass file.</p>
<p>If you need the position in the PostCSS input
(e.g., to debug the previous compiler), use <code>error.input.file</code>.</p>
<pre><code class="code language-js"><span class="code-comment">// Raising error from plugin</span>
<span class="code-keyword">throw</span> node.<span class="code-title function_">error</span>(<span class="code-string">'Unknown variable'</span>, { <span class="code-attr">plugin</span>: <span class="code-string">'postcss-vars'</span> })
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Catching and checking syntax error</span>
<span class="code-keyword">try</span> {
  postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{'</span>)
} <span class="code-keyword">catch</span> (error) {
  <span class="code-keyword">if</span> (error.<span class="code-property">name</span> === <span class="code-string">'CssSyntaxError'</span>) {
    error <span class="code-comment">//=> CssSyntaxError</span>
  }
}
</code></pre><h2 id="csssyntaxerror-capturestacktrace" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>captureStackTrace()</h2><p>Create .stack property on a target object</p><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>targetObject</code></td><td>object</td></tr><tr><td><code>constructorOpt</code></td><td>Function</td></tr></table><h2 id="csssyntaxerror-column" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>column</h2><p>Source column of the error.</p>
<pre><code class="code language-js">error.<span class="code-property">column</span>       <span class="code-comment">//=> 1</span>
error.<span class="code-property">input</span>.<span class="code-property">column</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.column</code>.</p><p>Type: number.</p><h2 id="csssyntaxerror-endcolumn" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>endColumn</h2><p>Source column of the error's end, exclusive. Provided if the error pertains
to a range.</p>
<pre><code class="code language-js">error.<span class="code-property">endColumn</span>       <span class="code-comment">//=> 1</span>
error.<span class="code-property">input</span>.<span class="code-property">endColumn</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.endColumn</code>.</p><p>Type: number.</p><h2 id="csssyntaxerror-endline" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>endLine</h2><p>Source line of the error's end, exclusive. Provided if the error pertains
to a range.</p>
<pre><code class="code language-js">error.<span class="code-property">endLine</span>       <span class="code-comment">//=> 3</span>
error.<span class="code-property">input</span>.<span class="code-property">endLine</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.endLine</code>.</p><p>Type: number.</p><h2 id="csssyntaxerror-file" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>file</h2><p>Absolute path to the broken file.</p>
<pre><code class="code language-js">error.<span class="code-property">file</span>       <span class="code-comment">//=> 'a.sass'</span>
error.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> 'a.css'</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.file</code>.</p><p>Type: string.</p><h2 id="csssyntaxerror-input" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>input</h2><p>Input object with PostCSS internal information
about input file. If input has source map
from previous tool, PostCSS will use origin
(for example, Sass) source. You can use this
object to get PostCSS input source.</p>
<pre><code class="code language-js">error.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> 'a.css'</span>
error.<span class="code-property">file</span>       <span class="code-comment">//=> 'a.sass'</span>
</code></pre><p>Type: <a href="#fileposition">FilePosition</a>.</p><h2 id="csssyntaxerror-line" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>line</h2><p>Source line of the error.</p>
<pre><code class="code language-js">error.<span class="code-property">line</span>       <span class="code-comment">//=> 2</span>
error.<span class="code-property">input</span>.<span class="code-property">line</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.line</code>.</p><p>Type: number.</p><h2 id="csssyntaxerror-message" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>message</h2><p>Full error text in the GNU error format
with plugin, file, line and column.</p>
<pre><code class="code language-js">error.<span class="code-property">message</span> <span class="code-comment">//=> 'a.css:1:1: Unclosed block'</span>
</code></pre><p>Type: string.</p><h2 id="csssyntaxerror-name" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>name</h2><p>Always equal to <code>'CssSyntaxError'</code>. You should always check error type
by <code>error.name === 'CssSyntaxError'</code>
instead of <code>error instanceof CssSyntaxError</code>,
because npm could have several PostCSS versions.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (error.<span class="code-property">name</span> === <span class="code-string">'CssSyntaxError'</span>) {
  error <span class="code-comment">//=> CssSyntaxError</span>
}
</code></pre><p>Type: "<a href="#csssyntaxerror">CssSyntaxError</a>".</p><h2 id="csssyntaxerror-plugin" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>plugin</h2><p>Plugin name, if error came from plugin.</p>
<pre><code class="code language-js">error.<span class="code-property">plugin</span> <span class="code-comment">//=> 'postcss-vars'</span>
</code></pre><p>Type: string.</p><h2 id="csssyntaxerror-preparestacktrace" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>prepareStackTrace</h2><p>Type: Function.</p><h2 id="csssyntaxerror-reason" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>reason</h2><p>Error message.</p>
<pre><code class="code language-js">error.<span class="code-property">message</span> <span class="code-comment">//=> 'Unclosed block'</span>
</code></pre><p>Type: string.</p><h2 id="csssyntaxerror-showsourcecode" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>showSourceCode()</h2><p>Returns a few lines of CSS source that caused the error.</p>
<p>If the CSS has an input source map without <code>sourceContent</code>,
this method will return an empty string.</p>
<pre><code class="code language-js">error.<span class="code-title function_">showSourceCode</span>() <span class="code-comment">//=> "  4 | }</span>
                       <span class="code-comment">//      5 | a {</span>
                       <span class="code-comment">//    > 6 |   bad</span>
                       <span class="code-comment">//        |   ^</span>
                       <span class="code-comment">//      7 | }</span>
                       <span class="code-comment">//      8 | b {"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>color</code></td><td>boolean</td><td>Whether arrow will be colored red by terminal
color codes. By default, PostCSS will detect
color support by <code>process.stdout.isTTY</code>
and <code>process.env.NODE_DISABLE_COLORS</code>.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="csssyntaxerror-source" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>source</h2><p>Source code of the broken file.</p>
<pre><code class="code language-js">error.<span class="code-property">source</span>       <span class="code-comment">//=> 'a { b {} }'</span>
error.<span class="code-property">input</span>.<span class="code-property">source</span> <span class="code-comment">//=> 'a b { }'</span>
</code></pre><p>Type: string.</p><h2 id="csssyntaxerror-stack" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>stack</h2><p>Type: string.</p><h2 id="csssyntaxerror-stacktracelimit" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>stackTraceLimit</h2><p>Type: number.</p><h2 id="csssyntaxerror-tostring" class="doc_subtitle"><span class="doc_prefix">CssSyntaxError#</span>toString()</h2><p>Returns error position, message and source code of the broken part.</p>
<pre><code class="code language-js">error.<span class="code-title function_">toString</span>() <span class="code-comment">//=> "CssSyntaxError: app.css:1:1: Unclosed block</span>
                 <span class="code-comment">//    > 1 | a {</span>
                 <span class="code-comment">//        | ^"</span>
</code></pre><p>Returns <code>string</code>. </p></section><section class="doc"><h1 id="declaration" class="doc_title">Declaration</h1><p>It represents a class that handles
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax#css_declarations">CSS declarations</a></p>
<pre><code class="code language-js"><span class="code-title class_">Once</span> (root, { <span class="code-title class_">Declaration</span> }) {
  <span class="code-keyword">const</span> color = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
  root.<span class="code-title function_">append</span>(color)
}
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
<span class="code-keyword">const</span> decl = root.<span class="code-property">first</span>?.<span class="code-property">first</span>

decl.<span class="code-property">type</span>       <span class="code-comment">//=> 'decl'</span>
decl.<span class="code-title function_">toString</span>() <span class="code-comment">//=> ' color: black'</span>
</code></pre><h2 id="declaration-after" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-assign" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#declarationprops">DeclarationProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-before" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-cleanraws" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="declaration-clone" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-cloneafter" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-clonebefore" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-error" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="declaration-markdirty" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="declaration-next" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="declaration-parent" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: <a href="#containerwithchildren">ContainerWithChildren</a>.</p><h2 id="declaration-positionby" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="declaration-positioninside" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="declaration-prev" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="declaration-rangeby" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="declaration-raw" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="declaration-raws" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#declarationraws">DeclarationRaws</a>.</p><h2 id="declaration-remove" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-replacewith" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#declaration">Declaration</a></code>. </p><h2 id="declaration-root" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="declaration-source" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="declaration-tojson" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="declaration-tostring" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="declaration-type" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "decl".</p><h2 id="declaration-warn" class="doc_subtitle"><span class="doc_prefix">Declaration#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="document" class="doc_title">Document</h1><p>Represents a file and contains all its parsed nodes.</p>
<p><strong>Experimental:</strong> some aspects of this node could change within minor
or patch version releases.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> <span class="code-variable language_">document</span> = <span class="code-title function_">htmlParser</span>(
  <span class="code-string">'&#x3C;html>&#x3C;style>a{color:black}&#x3C;/style>&#x3C;style>b{z-index:2}&#x3C;/style>'</span>
)
<span class="code-variable language_">document</span>.<span class="code-property">type</span>         <span class="code-comment">//=> 'document'</span>
<span class="code-variable language_">document</span>.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 2</span>
</code></pre><h2 id="document-after" class="doc_subtitle"><span class="doc_prefix">Document#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-append" class="doc_subtitle"><span class="doc_prefix">Document#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-assign" class="doc_subtitle"><span class="doc_prefix">Document#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#documentprops">DocumentProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-before" class="doc_subtitle"><span class="doc_prefix">Document#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-cleanraws" class="doc_subtitle"><span class="doc_prefix">Document#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="document-clone" class="doc_subtitle"><span class="doc_prefix">Document#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#documentprops">DocumentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-cloneafter" class="doc_subtitle"><span class="doc_prefix">Document#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#documentprops">DocumentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-clonebefore" class="doc_subtitle"><span class="doc_prefix">Document#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#documentprops">DocumentProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-each" class="doc_subtitle"><span class="doc_prefix">Document#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-error" class="doc_subtitle"><span class="doc_prefix">Document#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="document-every" class="doc_subtitle"><span class="doc_prefix">Document#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="document-index" class="doc_subtitle"><span class="doc_prefix">Document#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#root">Root</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="document-insertafter" class="doc_subtitle"><span class="doc_prefix">Document#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#root">Root</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-insertbefore" class="doc_subtitle"><span class="doc_prefix">Document#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#root">Root</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-markdirty" class="doc_subtitle"><span class="doc_prefix">Document#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="document-next" class="doc_subtitle"><span class="doc_prefix">Document#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="document-nodes" class="doc_subtitle"><span class="doc_prefix">Document#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: <a href="#root">Root</a>[].</p><h2 id="document-parent" class="doc_subtitle"><span class="doc_prefix">Document#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: undefined.</p><h2 id="document-positionby" class="doc_subtitle"><span class="doc_prefix">Document#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="document-positioninside" class="doc_subtitle"><span class="doc_prefix">Document#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="document-prepend" class="doc_subtitle"><span class="doc_prefix">Document#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-prev" class="doc_subtitle"><span class="doc_prefix">Document#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="document-push" class="doc_subtitle"><span class="doc_prefix">Document#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#root">Root</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-rangeby" class="doc_subtitle"><span class="doc_prefix">Document#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="document-raw" class="doc_subtitle"><span class="doc_prefix">Document#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="document-raws" class="doc_subtitle"><span class="doc_prefix">Document#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: any.</p><h2 id="document-remove" class="doc_subtitle"><span class="doc_prefix">Document#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-removeall" class="doc_subtitle"><span class="doc_prefix">Document#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-removechild" class="doc_subtitle"><span class="doc_prefix">Document#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#root">Root</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-replacevalues" class="doc_subtitle"><span class="doc_prefix">Document#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-replacewith" class="doc_subtitle"><span class="doc_prefix">Document#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#document">Document</a></code>. </p><h2 id="document-root" class="doc_subtitle"><span class="doc_prefix">Document#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="document-some" class="doc_subtitle"><span class="doc_prefix">Document#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="document-source" class="doc_subtitle"><span class="doc_prefix">Document#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="document-tojson" class="doc_subtitle"><span class="doc_prefix">Document#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="document-toresult" class="doc_subtitle"><span class="doc_prefix">Document#</span>toResult()</h2><p>Returns a <code><a href="#result">Result</a></code> instance representing the document’s CSS roots.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root1 = postcss.<span class="code-title function_">parse</span>(css1, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span> })
<span class="code-keyword">const</span> root2 = postcss.<span class="code-title function_">parse</span>(css2, { <span class="code-attr">from</span>: <span class="code-string">'b.css'</span> })
<span class="code-keyword">const</span> <span class="code-variable language_">document</span> = postcss.<span class="code-title function_">document</span>()
<span class="code-variable language_">document</span>.<span class="code-title function_">append</span>(root1)
<span class="code-variable language_">document</span>.<span class="code-title function_">append</span>(root2)
<span class="code-keyword">const</span> result = <span class="code-variable language_">document</span>.<span class="code-title function_">toResult</span>({ <span class="code-attr">to</span>: <span class="code-string">'all.css'</span>, <span class="code-attr">map</span>: <span class="code-literal">true</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a>&lt;Document_ | <a href="#root">Root</a>></td></tr></table><p>Returns <code><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></code>. </p><h2 id="document-tostring" class="doc_subtitle"><span class="doc_prefix">Document#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="document-type" class="doc_subtitle"><span class="doc_prefix">Document#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "document".</p><h2 id="document-walk" class="doc_subtitle"><span class="doc_prefix">Document#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkatrules" class="doc_subtitle"><span class="doc_prefix">Document#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkcomments" class="doc_subtitle"><span class="doc_prefix">Document#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkdecls" class="doc_subtitle"><span class="doc_prefix">Document#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkrules" class="doc_subtitle"><span class="doc_prefix">Document#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-warn" class="doc_subtitle"><span class="doc_prefix">Document#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="input" class="doc_title">Input</h1><p>Represents the source CSS.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root  = postcss.<span class="code-title function_">parse</span>(css, { <span class="code-attr">from</span>: file })
<span class="code-keyword">const</span> input = root.<span class="code-property">source</span>.<span class="code-property">input</span>
</code></pre><h2 id="input-css" class="doc_subtitle"><span class="doc_prefix">Input#</span>css</h2><p>Input CSS source.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> input = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{}'</span>, { <span class="code-attr">from</span>: file }).<span class="code-property">input</span>
input.<span class="code-property">css</span> <span class="code-comment">//=> "a{}"</span>
</code></pre><p>Type: string.</p><h2 id="input-document" class="doc_subtitle"><span class="doc_prefix">Input#</span>document</h2><p>Input source with support for non-CSS documents.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> input = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{}'</span>, { <span class="code-attr">from</span>: file, <span class="code-attr">document</span>: <span class="code-string">'&#x3C;style>a {}&#x3C;/style>'</span> }).<span class="code-property">input</span>
input.<span class="code-property">document</span> <span class="code-comment">//=> "&#x3C;style>a {}&#x3C;/style>"</span>
input.<span class="code-property">css</span> <span class="code-comment">//=> "a{}"</span>
</code></pre><p>Type: string.</p><h2 id="input-error" class="doc_subtitle"><span class="doc_prefix">Input#</span>error()</h2><p>Returns <code><a href="#csssyntaxerror">CssSyntaxError</a></code> with information about the error and its position.</p><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>start</code></td><td>Object | Object</td></tr><tr><td><code>end</code></td><td>Object | Object</td></tr><tr><td><code>opts</code></td><td>Object</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>line</code></td><td>number</td></tr><tr><td><code>column</code></td><td>number</td></tr><tr><td><code>opts</code></td><td>Object</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>offset</code></td><td>number</td></tr><tr><td><code>opts</code></td><td>Object</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="input-file" class="doc_subtitle"><span class="doc_prefix">Input#</span>file</h2><p>The absolute path to the CSS source file defined
with the <code>from</code> option.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(css, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span> })
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> '/home/ai/a.css'</span>
</code></pre><p>Type: string.</p><h2 id="input-fromlineandcolumn" class="doc_subtitle"><span class="doc_prefix">Input#</span>fromLineAndColumn()</h2><p>Converts source line and column to offset.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>line</code></td><td>number</td><td>Source line.</td></tr><tr><td><code>column</code></td><td>number</td><td>Source column.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="input-fromoffset" class="doc_subtitle"><span class="doc_prefix">Input#</span>fromOffset()</h2><p>Converts source offset to line and column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>number</td><td>Source offset.</td></tr></table><p>Returns <code>Object</code>. </p><h2 id="input-hasbom" class="doc_subtitle"><span class="doc_prefix">Input#</span>hasBOM</h2><p>The flag to indicate whether or not the source code has Unicode BOM.</p><p>Type: boolean.</p><h2 id="input-id" class="doc_subtitle"><span class="doc_prefix">Input#</span>id</h2><p>The unique ID of the CSS source. It will be created if <code>from</code> option
is not provided (because PostCSS does not know the file path).</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(css)
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> undefined</span>
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">id</span>   <span class="code-comment">//=> "&#x3C;input css 8LZeVF>"</span>
</code></pre><p>Type: string.</p><h2 id="input-map" class="doc_subtitle"><span class="doc_prefix">Input#</span>map</h2><p>The input source map passed from a compilation step before PostCSS
(for example, from Sass compiler).</p>
<pre><code class="code language-js">root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">map</span>.<span class="code-title function_">consumer</span>().<span class="code-property">sources</span> <span class="code-comment">//=> ['a.sass']</span>
</code></pre><p>Type: PreviousMap_.</p><h2 id="input-origin" class="doc_subtitle"><span class="doc_prefix">Input#</span>origin()</h2><p>Reads the input source map and returns a symbol position
in the input source (e.g., in a Sass file that was compiled
to CSS before being passed to PostCSS). Optionally takes an
end position, exclusive.</p>
<pre><code class="code language-js">root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-title function_">origin</span>(<span class="code-number">1</span>, <span class="code-number">1</span>) <span class="code-comment">//=> { file: 'a.css', line: 3, column: 1 }</span>
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-title function_">origin</span>(<span class="code-number">1</span>, <span class="code-number">1</span>, <span class="code-number">1</span>, <span class="code-number">4</span>)
<span class="code-comment">//=> { file: 'a.css', line: 3, column: 1, endLine: 3, endColumn: 4 }</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>line</code></td><td>number</td><td>Line for inclusive start position in input CSS.</td></tr><tr><td><code>column</code></td><td>number</td><td>Column for inclusive start position in input CSS.</td></tr><tr><td><code>endLine</code></td><td>number</td><td>Line for exclusive end position in input CSS.</td></tr><tr><td><code>endColumn</code></td><td>number</td><td>Column for exclusive end position in input CSS.</td></tr></table><p>Returns <code>false | <a href="#fileposition">FilePosition</a></code>. </p><h2 id="input-tojson" class="doc_subtitle"><span class="doc_prefix">Input#</span>toJSON()</h2><p>Converts this to a JSON-friendly object representation.</p><p>Returns <code>object</code>. </p></section><section class="doc"><h1 id="lazyresult" class="doc_title">LazyResult</h1><p>A Promise proxy for the result of PostCSS transformations.</p>
<p>A <code><a href="#lazyresult">LazyResult</a></code> instance is returned by <code><a href="#processor-process">Processor#process</a></code>.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> lazy = <span class="code-title function_">postcss</span>([autoprefixer]).<span class="code-title function_">process</span>(css)
</code></pre><h2 id="lazyresult-async" class="doc_subtitle"><span class="doc_prefix">LazyResult#</span>async()</h2><p>Run plugin in async way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code>Promise&lt;<a href="#result">Result</a>&lt;RootNode>></code>. </p><h2 id="lazyresult-catch" class="doc_subtitle"><span class="doc_prefix">LazyResult#</span>catch</h2><p>Type: Function.</p><h2 id="lazyresult-finally" class="doc_subtitle"><span class="doc_prefix">LazyResult#</span>finally</h2><p>Type: Function.</p><h2 id="lazyresult-sync" class="doc_subtitle"><span class="doc_prefix">LazyResult#</span>sync()</h2><p>Run plugin in sync way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code><a href="#result">Result</a>&lt;RootNode></code>. </p><h2 id="lazyresult-then" class="doc_subtitle"><span class="doc_prefix">LazyResult#</span>then</h2><p>Type: Function.</p><h2 id="lazyresult-tostring" class="doc_subtitle"><span class="doc_prefix">LazyResult#</span>toString()</h2><p>Alias for the <code><a href="#lazyresult-css">LazyResult#css</a></code> property.</p>
<pre><code class="code language-js">lazy + <span class="code-string">''</span> === lazy.<span class="code-property">css</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="lazyresult-warnings" class="doc_subtitle"><span class="doc_prefix">LazyResult#</span>warnings()</h2><p>Processes input CSS through synchronous plugins
and calls <code><a href="#result-warnings">Result#warnings</a></code>.</p><p>Returns <code><a href="#warning">Warning</a>[]</code>. </p></section><section class="doc"><h1 id="noworkresult" class="doc_title">NoWorkResult</h1><p>A Promise proxy for the result of PostCSS transformations.
This lazy result instance doesn't parse css unless <code><a href="#noworkresult-root">NoWorkResult#root</a></code> or <code><a href="#result-root">Result#root</a></code>
are accessed. See the example below for details.
A <code>NoWork</code> instance is returned by <code><a href="#processor-process">Processor#process</a></code> ONLY when no plugins defined.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noWorkResult = <span class="code-title function_">postcss</span>().<span class="code-title function_">process</span>(css) <span class="code-comment">// No plugins are defined.</span>
                                            <span class="code-comment">// CSS is not parsed</span>
<span class="code-keyword">let</span> root = noWorkResult.<span class="code-property">root</span> <span class="code-comment">// now css is parsed because we accessed the root</span>
</code></pre><h2 id="noworkresult-async" class="doc_subtitle"><span class="doc_prefix">NoWorkResult#</span>async()</h2><p>Run plugin in async way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code>Promise&lt;<a href="#result">Result</a>&lt;<a href="#root">Root</a>>></code>. </p><h2 id="noworkresult-catch" class="doc_subtitle"><span class="doc_prefix">NoWorkResult#</span>catch</h2><p>Type: Function.</p><h2 id="noworkresult-finally" class="doc_subtitle"><span class="doc_prefix">NoWorkResult#</span>finally</h2><p>Type: Function.</p><h2 id="noworkresult-sync" class="doc_subtitle"><span class="doc_prefix">NoWorkResult#</span>sync()</h2><p>Run plugin in sync way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code><a href="#result">Result</a>&lt;<a href="#root">Root</a>></code>. </p><h2 id="noworkresult-then" class="doc_subtitle"><span class="doc_prefix">NoWorkResult#</span>then</h2><p>Type: Function.</p><h2 id="noworkresult-tostring" class="doc_subtitle"><span class="doc_prefix">NoWorkResult#</span>toString()</h2><p>Alias for the <code><a href="#lazyresult-css">LazyResult#css</a></code> property.</p>
<pre><code class="code language-js">lazy + <span class="code-string">''</span> === lazy.<span class="code-property">css</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="noworkresult-warnings" class="doc_subtitle"><span class="doc_prefix">NoWorkResult#</span>warnings()</h2><p>Processes input CSS through synchronous plugins
and calls <code><a href="#result-warnings">Result#warnings</a></code>.</p><p>Returns <code><a href="#warning">Warning</a>[]</code>. </p></section><section class="doc"><h1 id="node" class="doc_title">Node</h1><h2 id="node-after" class="doc_subtitle"><span class="doc_prefix">Node#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-assign" class="doc_subtitle"><span class="doc_prefix">Node#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-before" class="doc_subtitle"><span class="doc_prefix">Node#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-cleanraws" class="doc_subtitle"><span class="doc_prefix">Node#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="node-clone" class="doc_subtitle"><span class="doc_prefix">Node#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-cloneafter" class="doc_subtitle"><span class="doc_prefix">Node#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-clonebefore" class="doc_subtitle"><span class="doc_prefix">Node#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-error" class="doc_subtitle"><span class="doc_prefix">Node#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="node-markdirty" class="doc_subtitle"><span class="doc_prefix">Node#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="node-next" class="doc_subtitle"><span class="doc_prefix">Node#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="node-parent" class="doc_subtitle"><span class="doc_prefix">Node#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Container_&lt;<a href="#childnode">ChildNode</a>> | Document_.</p><h2 id="node-positionby" class="doc_subtitle"><span class="doc_prefix">Node#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="node-positioninside" class="doc_subtitle"><span class="doc_prefix">Node#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="node-prev" class="doc_subtitle"><span class="doc_prefix">Node#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="node-rangeby" class="doc_subtitle"><span class="doc_prefix">Node#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="node-raw" class="doc_subtitle"><span class="doc_prefix">Node#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="node-raws" class="doc_subtitle"><span class="doc_prefix">Node#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: any.</p><h2 id="node-remove" class="doc_subtitle"><span class="doc_prefix">Node#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-replacewith" class="doc_subtitle"><span class="doc_prefix">Node#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-root" class="doc_subtitle"><span class="doc_prefix">Node#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="node-source" class="doc_subtitle"><span class="doc_prefix">Node#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="node-tojson" class="doc_subtitle"><span class="doc_prefix">Node#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="node-tostring" class="doc_subtitle"><span class="doc_prefix">Node#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="node-type" class="doc_subtitle"><span class="doc_prefix">Node#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: string.</p><h2 id="node-warn" class="doc_subtitle"><span class="doc_prefix">Node#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="previousmap" class="doc_title">PreviousMap</h1><p>Source map information from input CSS.
For example, source map after Sass compiler.</p>
<p>This class will automatically find source map in input CSS or in file system
near input file (according <code>from</code> option).</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = <span class="code-title function_">parse</span>(css, { <span class="code-attr">from</span>: <span class="code-string">'a.sass.css'</span> })
root.<span class="code-property">input</span>.<span class="code-property">map</span> <span class="code-comment">//=> PreviousMap</span>
</code></pre><h2 id="previousmap-annotation" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>annotation</h2><p><code>sourceMappingURL</code> content.</p><p>Type: string.</p><h2 id="previousmap-consumer" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>consumer()</h2><p>Create a instance of <code>SourceMapGenerator</code> class
from the <code>source-map</code> library to work with source map information.</p>
<p>It is lazy method, so it will create object only on first call
and then it will use cache.</p><p>Returns <code>SourceMapConsumer</code>. </p><h2 id="previousmap-file" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>file</h2><p>The CSS source identifier. Contains <code><a href="#input-file">Input#file</a></code> if the user
set the <code>from</code> option, or <code><a href="#input-id">Input#id</a></code> if they did not.</p><p>Type: string.</p><h2 id="previousmap-inline" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>inline</h2><p>Was source map inlined by data-uri to input CSS.</p><p>Type: boolean.</p><h2 id="previousmap-mapfile" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>mapFile</h2><p>Path to source map file.</p><p>Type: string.</p><h2 id="previousmap-root" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>root</h2><p>The directory with source map file, if source map is in separated file.</p><p>Type: string.</p><h2 id="previousmap-text" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>text</h2><p>Source map file content.</p><p>Type: string.</p><h2 id="previousmap-withcontent" class="doc_subtitle"><span class="doc_prefix">PreviousMap#</span>withContent()</h2><p>Does source map contains <code>sourcesContent</code> with input source text.</p><p>Returns <code>boolean</code>. </p></section><section class="doc"><h1 id="processor" class="doc_title">Processor</h1><p>Contains plugins to process CSS. Create one <code><a href="#processor">Processor</a></code> instance,
initialize its plugins, and then use that instance on numerous CSS files.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> processor = <span class="code-title function_">postcss</span>([autoprefixer, postcssNested])
processor.<span class="code-title function_">process</span>(css1).<span class="code-title function_">then</span>(<span class="code-function"><span class="code-params">result</span> =></span> <span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(result.<span class="code-property">css</span>))
processor.<span class="code-title function_">process</span>(css2).<span class="code-title function_">then</span>(<span class="code-function"><span class="code-params">result</span> =></span> <span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(result.<span class="code-property">css</span>))
</code></pre><h2 id="processor-plugins" class="doc_subtitle"><span class="doc_prefix">Processor#</span>plugins</h2><p>Plugins added to this processor.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> processor = <span class="code-title function_">postcss</span>([autoprefixer, postcssNested])
processor.<span class="code-property">plugins</span>.<span class="code-property">length</span> <span class="code-comment">//=> 2</span>
</code></pre><p>Type: (<a href="#plugin">Plugin</a> | <a href="#transformcallback">TransformCallback</a> | <a href="#transformer">Transformer</a>)[].</p><h2 id="processor-process" class="doc_subtitle"><span class="doc_prefix">Processor#</span>process()</h2><p>Parses source CSS and returns a <code><a href="#lazyresult">LazyResult</a></code> Promise proxy.
Because some plugins can be asynchronous it doesn’t make
any transformations. Transformations will be applied
in the <code><a href="#lazyresult">LazyResult</a></code> methods.</p>
<pre><code class="code language-js">processor.<span class="code-title function_">process</span>(css, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span>, <span class="code-attr">to</span>: <span class="code-string">'a.out.css'</span> })
  .<span class="code-title function_">then</span>(<span class="code-function"><span class="code-params">result</span> =></span> {
     <span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(result.<span class="code-property">css</span>)
  })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>css</code></td><td>string | <a href="#root">Root</a> | <a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>> | Object | LazyResult_&lt;Document_ | <a href="#root">Root</a>></td><td>String with input CSS or any object with a <code>toString()</code> method,
like a Buffer. Optionally, send a <code><a href="#result">Result</a></code> instance
and the processor will take the <code><a href="#root">Root</a></code> from it.</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>css</code></td><td>string | <a href="#root">Root</a> | <a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>> | LazyResult_&lt;Document_ | <a href="#root">Root</a>> | Object</td><td>String with input CSS or any object with a <code>toString()</code> method,
like a Buffer. Optionally, send a <code><a href="#result">Result</a></code> instance
and the processor will take the <code><a href="#root">Root</a></code> from it.</td></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a>&lt;RootNode></td><td></td></tr></table><p>Returns <code>NoWorkResult_ | LazyResult_&lt;Document_ | <a href="#root">Root</a>></code>. </p><h2 id="processor-use" class="doc_subtitle"><span class="doc_prefix">Processor#</span>use()</h2><p>Adds a plugin to be used as a CSS processor.</p>
<p>PostCSS plugin can be in 4 formats:</p>
<ul>
<li>A plugin in <code><a href="#plugin">Plugin</a></code> format.</li>
<li>A plugin creator function with <code>pluginCreator.postcss = true</code>.
PostCSS will call this function without argument to get plugin.</li>
<li>A function. PostCSS will pass the function a Root
as the first argument and current <code><a href="#result">Result</a></code> instance
as the second.</li>
<li>Another <code><a href="#processor">Processor</a></code> instance. PostCSS will copy plugins
from that instance into this one.</li>
</ul>
<p>Plugins can also be added by passing them as arguments when creating
a <code>postcss</code> instance (see [<code>postcss(plugins)</code>]).</p>
<p>Asynchronous plugins should return a <code>Promise</code> instance.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> processor = <span class="code-title function_">postcss</span>()
  .<span class="code-title function_">use</span>(autoprefixer)
  .<span class="code-title function_">use</span>(postcssNested)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>plugin</code></td><td><a href="#acceptedplugin">AcceptedPlugin</a></td><td>PostCSS plugin or <code><a href="#processor">Processor</a></code> with plugins.</td></tr></table><p>Returns <code><a href="#processor">Processor</a></code>. </p><h2 id="processor-version" class="doc_subtitle"><span class="doc_prefix">Processor#</span>version</h2><p>Current PostCSS version.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (result.<span class="code-property">processor</span>.<span class="code-property">version</span>.<span class="code-title function_">split</span>(<span class="code-string">'.'</span>)[<span class="code-number">0</span>] !== <span class="code-string">'6'</span>) {
  <span class="code-keyword">throw</span> <span class="code-keyword">new</span> <span class="code-title class_">Error</span>(<span class="code-string">'This plugin works only with PostCSS 6'</span>)
}
</code></pre><p>Type: string.</p></section><section class="doc"><h1 id="result" class="doc_title">Result</h1><p>Provides the result of the PostCSS transformations.</p>
<p>A Result instance is returned by <code><a href="#lazyresult-then">LazyResult#then</a></code>
or <code><a href="#root-toresult">Root#toResult</a></code> methods.</p>
<pre><code class="code language-js"><span class="code-title function_">postcss</span>([autoprefixer]).<span class="code-title function_">process</span>(css).<span class="code-title function_">then</span>(<span class="code-function"><span class="code-params">result</span> =></span> {
 <span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(result.<span class="code-property">css</span>)
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">const</span> result2 = postcss.<span class="code-title function_">parse</span>(css).<span class="code-title function_">toResult</span>()
</code></pre><h2 id="result-css" class="doc_subtitle"><span class="doc_prefix">Result#</span>css</h2><p>A CSS string representing of <code><a href="#result-root">Result#root</a></code>.</p>
<pre><code class="code language-js">postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{}'</span>).<span class="code-title function_">toResult</span>().<span class="code-property">css</span> <span class="code-comment">//=> "a{}"</span>
</code></pre><p>Type: string.</p><h2 id="result-lastplugin" class="doc_subtitle"><span class="doc_prefix">Result#</span>lastPlugin</h2><p>Last runned PostCSS plugin.</p><p>Type: <a href="#plugin">Plugin</a> | <a href="#transformcallback">TransformCallback</a>.</p><h2 id="result-map" class="doc_subtitle"><span class="doc_prefix">Result#</span>map</h2><p>An instance of <code>SourceMapGenerator</code> class from the <code>source-map</code> library,
representing changes to the <code><a href="#result-root">Result#root</a></code> instance.</p>
<pre><code class="code language-js">result.<span class="code-property">map</span>.<span class="code-title function_">toJSON</span>() <span class="code-comment">//=> { version: 3, file: 'a.css', … }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (result.<span class="code-property">map</span>) {
  fs.<span class="code-title function_">writeFileSync</span>(result.<span class="code-property">opts</span>.<span class="code-property">to</span> + <span class="code-string">'.map'</span>, result.<span class="code-property">map</span>.<span class="code-title function_">toString</span>())
}
</code></pre><p>Type: <a href="#sourcemap">SourceMap</a>.</p><h2 id="result-messages" class="doc_subtitle"><span class="doc_prefix">Result#</span>messages</h2><p>Contains messages from plugins (e.g., warnings or custom messages).
Each message should have type and plugin properties.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">import</span>: (atRule, { result }) {
    <span class="code-keyword">const</span> importedFile = <span class="code-title function_">parseImport</span>(atRule)
    result.<span class="code-property">messages</span>.<span class="code-title function_">push</span>({
      <span class="code-attr">type</span>: <span class="code-string">'dependency'</span>,
      <span class="code-attr">plugin</span>: <span class="code-string">'postcss-import'</span>,
      <span class="code-attr">file</span>: importedFile,
      <span class="code-attr">parent</span>: result.<span class="code-property">opts</span>.<span class="code-property">from</span>
    })
  }
}
</code></pre><p>Type: <a href="#message">Message</a>[].</p><h2 id="result-opts" class="doc_subtitle"><span class="doc_prefix">Result#</span>opts</h2><p>Options from the <code><a href="#processor-process">Processor#process</a></code> or <code><a href="#root-toresult">Root#toResult</a></code> call
that produced this Result instance.]</p>
<pre><code class="code language-js">root.<span class="code-title function_">toResult</span>(opts).<span class="code-property">opts</span> === opts
</code></pre><p>Type: <a href="#resultoptions">ResultOptions</a>.</p><h2 id="result-processor" class="doc_subtitle"><span class="doc_prefix">Result#</span>processor</h2><p>The Processor instance used for this transformation.</p>
<pre><code class="code language-js"><span class="code-keyword">for</span> (<span class="code-keyword">const</span> plugin <span class="code-keyword">of</span> result.<span class="code-property">processor</span>.<span class="code-property">plugins</span>) {
  <span class="code-keyword">if</span> (plugin.<span class="code-property">postcssPlugin</span> === <span class="code-string">'postcss-bad'</span>) {
    <span class="code-keyword">throw</span> <span class="code-string">'postcss-good is incompatible with postcss-bad'</span>
  }
})
</code></pre><p>Type: <a href="#processor">Processor</a>.</p><h2 id="result-root" class="doc_subtitle"><span class="doc_prefix">Result#</span>root</h2><p>Root node after all transformations.</p>
<pre><code class="code language-js">root.<span class="code-title function_">toResult</span>().<span class="code-property">root</span> === root
</code></pre><p>Type: RootNode.</p><h2 id="result-tostring" class="doc_subtitle"><span class="doc_prefix">Result#</span>toString()</h2><p>Returns for <code><a href="#result-css">Result#css</a></code> content.</p>
<pre><code class="code language-js">result + <span class="code-string">''</span> === result.<span class="code-property">css</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="result-warn" class="doc_subtitle"><span class="doc_prefix">Result#</span>warn()</h2><p>Creates an instance of <code><a href="#warning">Warning</a></code> and adds it to <code><a href="#result-messages">Result#messages</a></code>.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">important</span>) {
  result.<span class="code-title function_">warn</span>(<span class="code-string">'Avoid !important'</span>, { <span class="code-attr">node</span>: decl, <span class="code-attr">word</span>: <span class="code-string">'!important'</span> })
}
</code></pre><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p><h2 id="result-warnings" class="doc_subtitle"><span class="doc_prefix">Result#</span>warnings()</h2><p>Returns warnings from plugins. Filters <code><a href="#warning">Warning</a></code> instances
from <code><a href="#result-messages">Result#messages</a></code>.</p>
<pre><code class="code language-js">result.<span class="code-title function_">warnings</span>().<span class="code-title function_">forEach</span>(<span class="code-function"><span class="code-params">warn</span> =></span> {
  <span class="code-variable language_">console</span>.<span class="code-title function_">warn</span>(warn.<span class="code-title function_">toString</span>())
})
</code></pre><p>Returns <code><a href="#warning">Warning</a>[]</code>. </p></section><section class="doc"><h1 id="root" class="doc_title">Root</h1><p>Represents a CSS file and contains all its parsed nodes.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{color:black} b{z-index:2}'</span>)
root.<span class="code-property">type</span>         <span class="code-comment">//=> 'root'</span>
root.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 2</span>
</code></pre><h2 id="root-after" class="doc_subtitle"><span class="doc_prefix">Root#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-append" class="doc_subtitle"><span class="doc_prefix">Root#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-assign" class="doc_subtitle"><span class="doc_prefix">Root#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#rootprops">RootProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-before" class="doc_subtitle"><span class="doc_prefix">Root#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-cleanraws" class="doc_subtitle"><span class="doc_prefix">Root#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="root-clone" class="doc_subtitle"><span class="doc_prefix">Root#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#rootprops">RootProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-cloneafter" class="doc_subtitle"><span class="doc_prefix">Root#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#rootprops">RootProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-clonebefore" class="doc_subtitle"><span class="doc_prefix">Root#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#rootprops">RootProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-each" class="doc_subtitle"><span class="doc_prefix">Root#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-error" class="doc_subtitle"><span class="doc_prefix">Root#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="root-every" class="doc_subtitle"><span class="doc_prefix">Root#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="root-index" class="doc_subtitle"><span class="doc_prefix">Root#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="root-insertafter" class="doc_subtitle"><span class="doc_prefix">Root#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-insertbefore" class="doc_subtitle"><span class="doc_prefix">Root#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-markdirty" class="doc_subtitle"><span class="doc_prefix">Root#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="root-next" class="doc_subtitle"><span class="doc_prefix">Root#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="root-nodes" class="doc_subtitle"><span class="doc_prefix">Root#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="root-parent" class="doc_subtitle"><span class="doc_prefix">Root#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Document_.</p><h2 id="root-positionby" class="doc_subtitle"><span class="doc_prefix">Root#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="root-positioninside" class="doc_subtitle"><span class="doc_prefix">Root#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="root-prepend" class="doc_subtitle"><span class="doc_prefix">Root#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-prev" class="doc_subtitle"><span class="doc_prefix">Root#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="root-push" class="doc_subtitle"><span class="doc_prefix">Root#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-rangeby" class="doc_subtitle"><span class="doc_prefix">Root#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="root-raw" class="doc_subtitle"><span class="doc_prefix">Root#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="root-raws" class="doc_subtitle"><span class="doc_prefix">Root#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#rootraws">RootRaws</a>.</p><h2 id="root-remove" class="doc_subtitle"><span class="doc_prefix">Root#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-removeall" class="doc_subtitle"><span class="doc_prefix">Root#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-removechild" class="doc_subtitle"><span class="doc_prefix">Root#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-replacevalues" class="doc_subtitle"><span class="doc_prefix">Root#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-replacewith" class="doc_subtitle"><span class="doc_prefix">Root#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-root" class="doc_subtitle"><span class="doc_prefix">Root#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-some" class="doc_subtitle"><span class="doc_prefix">Root#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="root-source" class="doc_subtitle"><span class="doc_prefix">Root#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="root-tojson" class="doc_subtitle"><span class="doc_prefix">Root#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="root-toresult" class="doc_subtitle"><span class="doc_prefix">Root#</span>toResult()</h2><p>Returns a <code><a href="#result">Result</a></code> instance representing the root’s CSS.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root1 = postcss.<span class="code-title function_">parse</span>(css1, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span> })
<span class="code-keyword">const</span> root2 = postcss.<span class="code-title function_">parse</span>(css2, { <span class="code-attr">from</span>: <span class="code-string">'b.css'</span> })
root1.<span class="code-title function_">append</span>(root2)
<span class="code-keyword">const</span> result = root1.<span class="code-title function_">toResult</span>({ <span class="code-attr">to</span>: <span class="code-string">'all.css'</span>, <span class="code-attr">map</span>: <span class="code-literal">true</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a>&lt;Document_ | <a href="#root">Root</a>></td><td>Options.</td></tr></table><p>Returns <code><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></code>. </p><h2 id="root-tostring" class="doc_subtitle"><span class="doc_prefix">Root#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="root-type" class="doc_subtitle"><span class="doc_prefix">Root#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "root".</p><h2 id="root-walk" class="doc_subtitle"><span class="doc_prefix">Root#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkatrules" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkcomments" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkdecls" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkrules" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-warn" class="doc_subtitle"><span class="doc_prefix">Root#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="rule" class="doc_title">Rule</h1><p>Represents a CSS rule: a selector followed by a declaration block.</p>
<pre><code class="code language-js"><span class="code-title class_">Once</span> (root, { <span class="code-title class_">Rule</span> }) {
  <span class="code-keyword">let</span> a = <span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })
  a.<span class="code-title function_">append</span>(…)
  root.<span class="code-title function_">append</span>(a)
}
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{}'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>
rule.<span class="code-property">type</span>       <span class="code-comment">//=> 'rule'</span>
rule.<span class="code-title function_">toString</span>() <span class="code-comment">//=> 'a{}'</span>
</code></pre><h2 id="rule-after" class="doc_subtitle"><span class="doc_prefix">Rule#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-append" class="doc_subtitle"><span class="doc_prefix">Rule#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-assign" class="doc_subtitle"><span class="doc_prefix">Rule#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#ruleprops">RuleProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-before" class="doc_subtitle"><span class="doc_prefix">Rule#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-cleanraws" class="doc_subtitle"><span class="doc_prefix">Rule#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="rule-clone" class="doc_subtitle"><span class="doc_prefix">Rule#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-cloneafter" class="doc_subtitle"><span class="doc_prefix">Rule#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-clonebefore" class="doc_subtitle"><span class="doc_prefix">Rule#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-each" class="doc_subtitle"><span class="doc_prefix">Rule#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-error" class="doc_subtitle"><span class="doc_prefix">Rule#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="rule-every" class="doc_subtitle"><span class="doc_prefix">Rule#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="rule-index" class="doc_subtitle"><span class="doc_prefix">Rule#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="rule-insertafter" class="doc_subtitle"><span class="doc_prefix">Rule#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-insertbefore" class="doc_subtitle"><span class="doc_prefix">Rule#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-markdirty" class="doc_subtitle"><span class="doc_prefix">Rule#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="rule-next" class="doc_subtitle"><span class="doc_prefix">Rule#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="rule-nodes" class="doc_subtitle"><span class="doc_prefix">Rule#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="rule-parent" class="doc_subtitle"><span class="doc_prefix">Rule#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: <a href="#containerwithchildren">ContainerWithChildren</a>.</p><h2 id="rule-positionby" class="doc_subtitle"><span class="doc_prefix">Rule#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="rule-positioninside" class="doc_subtitle"><span class="doc_prefix">Rule#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="rule-prepend" class="doc_subtitle"><span class="doc_prefix">Rule#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-prev" class="doc_subtitle"><span class="doc_prefix">Rule#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="rule-push" class="doc_subtitle"><span class="doc_prefix">Rule#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-rangeby" class="doc_subtitle"><span class="doc_prefix">Rule#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="rule-raw" class="doc_subtitle"><span class="doc_prefix">Rule#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="rule-raws" class="doc_subtitle"><span class="doc_prefix">Rule#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#ruleraws">RuleRaws</a>.</p><h2 id="rule-remove" class="doc_subtitle"><span class="doc_prefix">Rule#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-removeall" class="doc_subtitle"><span class="doc_prefix">Rule#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-removechild" class="doc_subtitle"><span class="doc_prefix">Rule#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-replacevalues" class="doc_subtitle"><span class="doc_prefix">Rule#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-replacewith" class="doc_subtitle"><span class="doc_prefix">Rule#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-root" class="doc_subtitle"><span class="doc_prefix">Rule#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="rule-some" class="doc_subtitle"><span class="doc_prefix">Rule#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="rule-source" class="doc_subtitle"><span class="doc_prefix">Rule#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="rule-tojson" class="doc_subtitle"><span class="doc_prefix">Rule#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="rule-tostring" class="doc_subtitle"><span class="doc_prefix">Rule#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="rule-type" class="doc_subtitle"><span class="doc_prefix">Rule#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "rule".</p><h2 id="rule-walk" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkatrules" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkcomments" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkdecls" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkrules" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-warn" class="doc_subtitle"><span class="doc_prefix">Rule#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="stringifier" class="doc_title">Stringifier</h1><h2 id="stringifier-atrule" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>atrule()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>AtRule_</td></tr><tr><td><code>semicolon</code></td><td>boolean</td></tr></table><h2 id="stringifier-beforeafter" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>beforeAfter()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>detect</code></td><td>"after" | "before"</td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-block" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>block()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>start</code></td><td>string</td></tr></table><h2 id="stringifier-body" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>body()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Container_&lt;<a href="#childnode">ChildNode</a>></td></tr></table><h2 id="stringifier-builder" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>builder</h2><p>Type: <a href="#builder">Builder</a>.</p><h2 id="stringifier-comment" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>comment()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Comment_</td></tr></table><h2 id="stringifier-decl" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>decl()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Declaration_</td></tr><tr><td><code>semicolon</code></td><td>boolean</td></tr></table><h2 id="stringifier-document" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>document()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Document_</td></tr></table><h2 id="stringifier-raw" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>raw()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>own</code></td><td>string</td></tr><tr><td><code>detect</code></td><td>string</td></tr></table><p>Returns <code>string | boolean</code>. </p><h2 id="stringifier-rawbeforeclose" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawBeforeClose()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforecomment" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawBeforeComment()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>node</code></td><td>Comment_</td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforedecl" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawBeforeDecl()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>node</code></td><td>Declaration_</td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforeopen" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawBeforeOpen()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforerule" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawBeforeRule()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawcolon" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawColon()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawemptybody" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawEmptyBody()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawindent" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawIndent()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawsemicolon" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawSemicolon()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="stringifier-rawvalue" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rawValue()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>prop</code></td><td>string</td></tr></table><p>Returns <code>string | number</code>. </p><h2 id="stringifier-root" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>root()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#root">Root</a></td></tr></table><h2 id="stringifier-rule" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>rule()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#rule">Rule</a></td></tr></table><h2 id="stringifier-stringify" class="doc_subtitle"><span class="doc_prefix">Stringifier#</span>stringify()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>semicolon</code></td><td>boolean</td></tr></table></section><section class="doc"><h1 id="warning" class="doc_title">Warning</h1><p>Represents a plugin’s warning. It can be created using <code><a href="#node-warn">Node#warn</a></code>.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">important</span>) {
  decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Avoid !important'</span>, { <span class="code-attr">word</span>: <span class="code-string">'!important'</span> })
}
</code></pre><h2 id="warning-column" class="doc_subtitle"><span class="doc_prefix">Warning#</span>column</h2><p>Column for inclusive start position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">column</span> <span class="code-comment">//=> 6</span>
</code></pre><p>Type: number.</p><h2 id="warning-endcolumn" class="doc_subtitle"><span class="doc_prefix">Warning#</span>endColumn</h2><p>Column for exclusive end position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">endColumn</span> <span class="code-comment">//=> 4</span>
</code></pre><p>Type: number.</p><h2 id="warning-endline" class="doc_subtitle"><span class="doc_prefix">Warning#</span>endLine</h2><p>Line for exclusive end position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">endLine</span> <span class="code-comment">//=> 6</span>
</code></pre><p>Type: number.</p><h2 id="warning-line" class="doc_subtitle"><span class="doc_prefix">Warning#</span>line</h2><p>Line for inclusive start position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">line</span> <span class="code-comment">//=> 5</span>
</code></pre><p>Type: number.</p><h2 id="warning-node" class="doc_subtitle"><span class="doc_prefix">Warning#</span>node</h2><p>Contains the CSS node that caused the warning.</p>
<pre><code class="code language-js">warning.<span class="code-property">node</span>.<span class="code-title function_">toString</span>() <span class="code-comment">//=> 'color: white !important'</span>
</code></pre><p>Type: <a href="#node">Node</a>.</p><h2 id="warning-plugin" class="doc_subtitle"><span class="doc_prefix">Warning#</span>plugin</h2><p>The name of the plugin that created this warning.
When you call <code><a href="#node-warn">Node#warn</a></code> it will fill this property automatically.</p>
<pre><code class="code language-js">warning.<span class="code-property">plugin</span> <span class="code-comment">//=> 'postcss-important'</span>
</code></pre><p>Type: string.</p><h2 id="warning-text" class="doc_subtitle"><span class="doc_prefix">Warning#</span>text</h2><p>The warning message.</p>
<pre><code class="code language-js">warning.<span class="code-property">text</span> <span class="code-comment">//=> 'Try to avoid !important'</span>
</code></pre><p>Type: string.</p><h2 id="warning-tostring" class="doc_subtitle"><span class="doc_prefix">Warning#</span>toString()</h2><p>Returns a warning position and message.</p>
<pre><code class="code language-js">warning.<span class="code-title function_">toString</span>() <span class="code-comment">//=> 'postcss-lint:a.css:10:14: Avoid !important'</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="warning-type" class="doc_subtitle"><span class="doc_prefix">Warning#</span>type</h2><p>Type to filter warnings from <code><a href="#result-messages">Result#messages</a></code>.
Always equal to <code>"warning"</code>.</p><p>Type: "warning".</p></section><section class="doc"><h1 id="atruleprops" class="doc_title">AtRuleProps</h1><h2 id="atruleprops-name" class="doc_subtitle"><span class="doc_prefix">AtRuleProps#</span>name</h2><p>Name of the at-rule.</p><p>Type: string.</p><h2 id="atruleprops-nodes" class="doc_subtitle"><span class="doc_prefix">AtRuleProps#</span>nodes</h2><p>Type: readonly (<a href="#node">Node</a> | <a href="#childprops">ChildProps</a>)[].</p><h2 id="atruleprops-params" class="doc_subtitle"><span class="doc_prefix">AtRuleProps#</span>params</h2><p>Parameters following the name of the at-rule.</p><p>Type: string | number.</p><h2 id="atruleprops-raws" class="doc_subtitle"><span class="doc_prefix">AtRuleProps#</span>raws</h2><p>Information used to generate byte-to-byte equal node string as it was in the origin input.</p><p>Type: <a href="#atruleraws">AtRuleRaws</a>.</p><h2 id="atruleprops-source" class="doc_subtitle"><span class="doc_prefix">AtRuleProps#</span>source</h2><p>Type: <a href="#source">Source</a>.</p></section><section class="doc"><h1 id="atruleraws" class="doc_title">AtRuleRaws</h1><h2 id="atruleraws-after" class="doc_subtitle"><span class="doc_prefix">AtRuleRaws#</span>after</h2><p>The space symbols after the last child of the node to the end of the node.</p><p>Type: string.</p><h2 id="atruleraws-aftername" class="doc_subtitle"><span class="doc_prefix">AtRuleRaws#</span>afterName</h2><p>The space between the at-rule name and its parameters.</p><p>Type: string.</p><h2 id="atruleraws-before" class="doc_subtitle"><span class="doc_prefix">AtRuleRaws#</span>before</h2><p>The space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</p><p>Type: string.</p><h2 id="atruleraws-between" class="doc_subtitle"><span class="doc_prefix">AtRuleRaws#</span>between</h2><p>The symbols between the last parameter and <code>{</code> for rules.</p><p>Type: string.</p><h2 id="atruleraws-params" class="doc_subtitle"><span class="doc_prefix">AtRuleRaws#</span>params</h2><p>The rule’s selector with comments.</p><p>Type: Object.</p><h2 id="atruleraws-semicolon" class="doc_subtitle"><span class="doc_prefix">AtRuleRaws#</span>semicolon</h2><p>Contains <code>true</code> if the last child has an (optional) semicolon.</p><p>Type: boolean.</p></section><section class="doc"><h1 id="commentprops" class="doc_title">CommentProps</h1><h2 id="commentprops-raws" class="doc_subtitle"><span class="doc_prefix">CommentProps#</span>raws</h2><p>Information used to generate byte-to-byte equal node string as it was in the origin input.</p><p>Type: <a href="#commentraws">CommentRaws</a>.</p><h2 id="commentprops-source" class="doc_subtitle"><span class="doc_prefix">CommentProps#</span>source</h2><p>Type: <a href="#source">Source</a>.</p><h2 id="commentprops-text" class="doc_subtitle"><span class="doc_prefix">CommentProps#</span>text</h2><p>Content of the comment.</p><p>Type: string.</p></section><section class="doc"><h1 id="commentraws" class="doc_title">CommentRaws</h1><h2 id="commentraws-before" class="doc_subtitle"><span class="doc_prefix">CommentRaws#</span>before</h2><p>The space symbols before the node.</p><p>Type: string.</p><h2 id="commentraws-left" class="doc_subtitle"><span class="doc_prefix">CommentRaws#</span>left</h2><p>The space symbols between <code>/*</code> and the comment’s text.</p><p>Type: string.</p><h2 id="commentraws-right" class="doc_subtitle"><span class="doc_prefix">CommentRaws#</span>right</h2><p>The space symbols between the comment’s text.</p><p>Type: string.</p></section><section class="doc"><h1 id="containerprops" class="doc_title">ContainerProps</h1><h2 id="containerprops-nodes" class="doc_subtitle"><span class="doc_prefix">ContainerProps#</span>nodes</h2><p>Type: readonly (<a href="#node">Node</a> | <a href="#childprops">ChildProps</a>)[].</p><h2 id="containerprops-source" class="doc_subtitle"><span class="doc_prefix">ContainerProps#</span>source</h2><p>Type: <a href="#source">Source</a>.</p></section><section class="doc"><h1 id="declarationprops" class="doc_title">DeclarationProps</h1><h2 id="declarationprops-important" class="doc_subtitle"><span class="doc_prefix">DeclarationProps#</span>important</h2><p>Whether the declaration has an <code>!important</code> annotation.</p><p>Type: boolean.</p><h2 id="declarationprops-prop" class="doc_subtitle"><span class="doc_prefix">DeclarationProps#</span>prop</h2><p>Name of the declaration.</p><p>Type: string.</p><h2 id="declarationprops-raws" class="doc_subtitle"><span class="doc_prefix">DeclarationProps#</span>raws</h2><p>Information used to generate byte-to-byte equal node string as it was in the origin input.</p><p>Type: <a href="#declarationraws">DeclarationRaws</a>.</p><h2 id="declarationprops-value" class="doc_subtitle"><span class="doc_prefix">DeclarationProps#</span>value</h2><p>Value of the declaration.</p><p>Type: string.</p></section><section class="doc"><h1 id="declarationraws" class="doc_title">DeclarationRaws</h1><h2 id="declarationraws-before" class="doc_subtitle"><span class="doc_prefix">DeclarationRaws#</span>before</h2><p>The space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</p><p>Type: string.</p><h2 id="declarationraws-between" class="doc_subtitle"><span class="doc_prefix">DeclarationRaws#</span>between</h2><p>The symbols between the property and value for declarations.</p><p>Type: string.</p><h2 id="declarationraws-important" class="doc_subtitle"><span class="doc_prefix">DeclarationRaws#</span>important</h2><p>The content of the important statement, if it is not just <code>!important</code>.</p><p>Type: string.</p><h2 id="declarationraws-value" class="doc_subtitle"><span class="doc_prefix">DeclarationRaws#</span>value</h2><p>Declaration value with comments.</p><p>Type: Object.</p></section><section class="doc"><h1 id="documentprops" class="doc_title">DocumentProps</h1><h2 id="documentprops-nodes" class="doc_subtitle"><span class="doc_prefix">DocumentProps#</span>nodes</h2><p>Type: readonly <a href="#root">Root</a>[].</p><h2 id="documentprops-raws" class="doc_subtitle"><span class="doc_prefix">DocumentProps#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties.</p><p>Type: Record&lt;string, any>.</p><h2 id="documentprops-source" class="doc_subtitle"><span class="doc_prefix">DocumentProps#</span>source</h2><p>Type: <a href="#source">Source</a>.</p></section><section class="doc"><h1 id="fileposition" class="doc_title">FilePosition</h1><h2 id="fileposition-column" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>column</h2><p>Column of inclusive start position in source file.</p><p>Type: number.</p><h2 id="fileposition-endcolumn" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>endColumn</h2><p>Column of exclusive end position in source file.</p><p>Type: number.</p><h2 id="fileposition-endline" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>endLine</h2><p>Line of exclusive end position in source file.</p><p>Type: number.</p><h2 id="fileposition-endoffset" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>endOffset</h2><p>Offset of exclusive end position in source file.</p><p>Type: number.</p><h2 id="fileposition-file" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>file</h2><p>Absolute path to the source file.</p><p>Type: string.</p><h2 id="fileposition-line" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>line</h2><p>Line of inclusive start position in source file.</p><p>Type: number.</p><h2 id="fileposition-offset" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>offset</h2><p>Offset of inclusive start position in source file.</p><p>Type: number.</p><h2 id="fileposition-source" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>source</h2><p>Source code.</p><p>Type: string.</p><h2 id="fileposition-url" class="doc_subtitle"><span class="doc_prefix">FilePosition#</span>url</h2><p>URL for the source file.</p><p>Type: string.</p></section><section class="doc"><h1 id="message" class="doc_title">Message</h1><h2 id="message-plugin" class="doc_subtitle"><span class="doc_prefix">Message#</span>plugin</h2><p>Source PostCSS plugin name.</p><p>Type: string.</p><h2 id="message-type" class="doc_subtitle"><span class="doc_prefix">Message#</span>type</h2><p>Message type.</p><p>Type: string.</p></section><section class="doc"><h1 id="message" class="doc_title">Message</h1><h2 id="message-plugin" class="doc_subtitle"><span class="doc_prefix">Message#</span>plugin</h2><p>Source PostCSS plugin name.</p><p>Type: string.</p><h2 id="message-type" class="doc_subtitle"><span class="doc_prefix">Message#</span>type</h2><p>Message type.</p><p>Type: string.</p></section><section class="doc"><h1 id="nodeerroroptions" class="doc_title">NodeErrorOptions</h1><h2 id="nodeerroroptions-endindex" class="doc_subtitle"><span class="doc_prefix">NodeErrorOptions#</span>endIndex</h2><p>An ending index inside a node's string that should be highlighted as
source of error.</p><p>Type: number.</p><h2 id="nodeerroroptions-index" class="doc_subtitle"><span class="doc_prefix">NodeErrorOptions#</span>index</h2><p>An index inside a node's string that should be highlighted as source
of error.</p><p>Type: number.</p><h2 id="nodeerroroptions-plugin" class="doc_subtitle"><span class="doc_prefix">NodeErrorOptions#</span>plugin</h2><p>Plugin name that created this error. PostCSS will set it automatically.</p><p>Type: string.</p><h2 id="nodeerroroptions-word" class="doc_subtitle"><span class="doc_prefix">NodeErrorOptions#</span>word</h2><p>A word inside a node's string, that should be highlighted as source
of error.</p><p>Type: string.</p></section><section class="doc"><h1 id="nodeprops" class="doc_title">NodeProps</h1><h2 id="nodeprops-source" class="doc_subtitle"><span class="doc_prefix">NodeProps#</span>source</h2><p>Type: <a href="#source">Source</a>.</p></section><section class="doc"><h1 id="oldplugin" class="doc_title">OldPlugin</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>opts</code></td><td>T</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td></tr></table><p>Returns <code><a href="#transformer">Transformer</a></code>. </p><h2 id="oldplugin-postcss" class="doc_subtitle"><span class="doc_prefix">OldPlugin#</span>postcss</h2><p>Type: <a href="#transformer">Transformer</a>.</p><h2 id="oldplugin-postcssplugin" class="doc_subtitle"><span class="doc_prefix">OldPlugin#</span>postcssPlugin</h2><p>Type: string.</p><h2 id="oldplugin-postcssversion" class="doc_subtitle"><span class="doc_prefix">OldPlugin#</span>postcssVersion</h2><p>Type: string.</p></section><section class="doc"><h1 id="plugin" class="doc_title">Plugin</h1><h2 id="plugin-atrule" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>AtRule</h2><p>Will be called on all<code><a href="#atrule">AtRule</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p><p>Type: AtRuleProcessor | Object.</p><h2 id="plugin-atruleexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>AtRuleExit</h2><p>Will be called on all <code><a href="#atrule">AtRule</a></code> nodes, when all children will be processed.</p>
<p>Will be called again on node or children changes.</p><p>Type: AtRuleProcessor | Object.</p><h2 id="plugin-comment" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Comment</h2><p>Will be called on all <code><a href="#comment">Comment</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p><p>Type: CommentProcessor.</p><h2 id="plugin-commentexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>CommentExit</h2><p>Will be called on all <code><a href="#comment">Comment</a></code> nodes after listeners
for <code><a href="#comment">Comment</a></code> event.</p>
<p>Will be called again on node or children changes.</p><p>Type: CommentProcessor.</p><h2 id="plugin-declaration" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Declaration</h2><p>Will be called on all <code><a href="#declaration">Declaration</a></code> nodes after listeners
for <code><a href="#declaration">Declaration</a></code> event.</p>
<p>Will be called again on node or children changes.</p><p>Type: DeclarationProcessor | Object.</p><h2 id="plugin-declarationexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>DeclarationExit</h2><p>Will be called on all <code><a href="#declaration">Declaration</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p><p>Type: DeclarationProcessor | Object.</p><h2 id="plugin-document" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Document</h2><p>Will be called on <code><a href="#document">Document</a></code> node.</p>
<p>Will be called again on children changes.</p><p>Type: DocumentProcessor.</p><h2 id="plugin-documentexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>DocumentExit</h2><p>Will be called on <code><a href="#document">Document</a></code> node, when all children will be processed.</p>
<p>Will be called again on children changes.</p><p>Type: DocumentProcessor.</p><h2 id="plugin-once" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Once</h2><p>Will be called on <code><a href="#root">Root</a></code> node once.</p><p>Type: RootProcessor.</p><h2 id="plugin-onceexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>OnceExit</h2><p>Will be called on <code><a href="#root">Root</a></code> node once, when all children will be processed.</p><p>Type: RootProcessor.</p><h2 id="plugin-root" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Root</h2><p>Will be called on <code><a href="#root">Root</a></code> node.</p>
<p>Will be called again on children changes.</p><p>Type: RootProcessor.</p><h2 id="plugin-rootexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>RootExit</h2><p>Will be called on <code><a href="#root">Root</a></code> node, when all children will be processed.</p>
<p>Will be called again on children changes.</p><p>Type: RootProcessor.</p><h2 id="plugin-rule" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Rule</h2><p>Will be called on all <code><a href="#rule">Rule</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p><p>Type: RuleProcessor.</p><h2 id="plugin-ruleexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>RuleExit</h2><p>Will be called on all <code><a href="#rule">Rule</a></code> nodes, when all children will be processed.</p>
<p>Will be called again on node or children changes.</p><p>Type: RuleProcessor.</p><h2 id="plugin-postcssplugin" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>postcssPlugin</h2><p>Type: string.</p><h2 id="plugin-prepare" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>prepare</h2><p>Type: Function.</p></section><section class="doc"><h1 id="plugincreator" class="doc_title">PluginCreator</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>opts</code></td><td>PluginOptions</td></tr></table><p>Returns <code><a href="#processor">Processor</a> | <a href="#plugin">Plugin</a></code>. </p><h2 id="plugincreator-postcss" class="doc_subtitle"><span class="doc_prefix">PluginCreator#</span>postcss</h2><p>Type: true.</p></section><section class="doc"><h1 id="position" class="doc_title">Position</h1><h2 id="position-column" class="doc_subtitle"><span class="doc_prefix">Position#</span>column</h2><p>Source line in file. In contrast to <code>offset</code> it starts from 1.</p><p>Type: number.</p><h2 id="position-line" class="doc_subtitle"><span class="doc_prefix">Position#</span>line</h2><p>Source column in file.</p><p>Type: number.</p><h2 id="position-offset" class="doc_subtitle"><span class="doc_prefix">Position#</span>offset</h2><p>Source offset in file. It starts from 0.</p><p>Type: number.</p></section><section class="doc"><h1 id="processoptions" class="doc_title">ProcessOptions</h1><h2 id="processoptions-document" class="doc_subtitle"><span class="doc_prefix">ProcessOptions#</span>document</h2><p>Input file if it is not simple CSS file, but HTML with  or JS with CSS-in-JS blocks.</p><p>Type: string.</p><h2 id="processoptions-from" class="doc_subtitle"><span class="doc_prefix">ProcessOptions#</span>from</h2><p>The path of the CSS source file. You should always set <code>from</code>,
because it is used in source map generation and syntax error messages.</p><p>Type: string.</p><h2 id="processoptions-map" class="doc_subtitle"><span class="doc_prefix">ProcessOptions#</span>map</h2><p>Source map options</p><p>Type: boolean | <a href="#sourcemapoptions">SourceMapOptions</a>.</p><h2 id="processoptions-parser" class="doc_subtitle"><span class="doc_prefix">ProcessOptions#</span>parser</h2><p>Function to generate AST by string.</p><p>Type: <a href="#parser">Parser</a>&lt;RootNode> | <a href="#syntax">Syntax</a>&lt;RootNode>.</p><h2 id="processoptions-stringifier" class="doc_subtitle"><span class="doc_prefix">ProcessOptions#</span>stringifier</h2><p>Class to generate string by AST.</p><p>Type: <a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;RootNode>.</p><h2 id="processoptions-syntax" class="doc_subtitle"><span class="doc_prefix">ProcessOptions#</span>syntax</h2><p>Object with parse and stringify.</p><p>Type: <a href="#syntax">Syntax</a>&lt;RootNode>.</p><h2 id="processoptions-to" class="doc_subtitle"><span class="doc_prefix">ProcessOptions#</span>to</h2><p>The path where you'll put the output CSS file. You should always set <code>to</code>
to generate correct source maps.</p><p>Type: string.</p></section><section class="doc"><h1 id="processor" class="doc_title">Processor</h1><h2 id="processor-plugins" class="doc_subtitle"><span class="doc_prefix">Processor#</span>plugins</h2><p>Plugins added to this processor.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> processor = <span class="code-title function_">postcss</span>([autoprefixer, postcssNested])
processor.<span class="code-property">plugins</span>.<span class="code-property">length</span> <span class="code-comment">//=> 2</span>
</code></pre><p>Type: (<a href="#plugin">Plugin</a> | <a href="#transformcallback">TransformCallback</a> | <a href="#transformer">Transformer</a>)[].</p><h2 id="processor-process" class="doc_subtitle"><span class="doc_prefix">Processor#</span>process()</h2><p>Parses source CSS and returns a <code><a href="#lazyresult">LazyResult</a></code> Promise proxy.
Because some plugins can be asynchronous it doesn’t make
any transformations. Transformations will be applied
in the <code><a href="#lazyresult">LazyResult</a></code> methods.</p>
<pre><code class="code language-js">processor.<span class="code-title function_">process</span>(css, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span>, <span class="code-attr">to</span>: <span class="code-string">'a.out.css'</span> })
  .<span class="code-title function_">then</span>(<span class="code-function"><span class="code-params">result</span> =></span> {
     <span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(result.<span class="code-property">css</span>)
  })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>css</code></td><td>string | <a href="#root">Root</a> | <a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>> | Object | LazyResult_&lt;Document_ | <a href="#root">Root</a>></td><td>String with input CSS or any object with a <code>toString()</code> method,
like a Buffer. Optionally, send a <code><a href="#result">Result</a></code> instance
and the processor will take the <code><a href="#root">Root</a></code> from it.</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>css</code></td><td>string | <a href="#root">Root</a> | <a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>> | LazyResult_&lt;Document_ | <a href="#root">Root</a>> | Object</td><td>String with input CSS or any object with a <code>toString()</code> method,
like a Buffer. Optionally, send a <code><a href="#result">Result</a></code> instance
and the processor will take the <code><a href="#root">Root</a></code> from it.</td></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a>&lt;RootNode></td><td></td></tr></table><p>Returns <code>NoWorkResult_ | LazyResult_&lt;Document_ | <a href="#root">Root</a>></code>. </p><h2 id="processor-use" class="doc_subtitle"><span class="doc_prefix">Processor#</span>use()</h2><p>Adds a plugin to be used as a CSS processor.</p>
<p>PostCSS plugin can be in 4 formats:</p>
<ul>
<li>A plugin in <code><a href="#plugin">Plugin</a></code> format.</li>
<li>A plugin creator function with <code>pluginCreator.postcss = true</code>.
PostCSS will call this function without argument to get plugin.</li>
<li>A function. PostCSS will pass the function a Root
as the first argument and current <code><a href="#result">Result</a></code> instance
as the second.</li>
<li>Another <code><a href="#processor">Processor</a></code> instance. PostCSS will copy plugins
from that instance into this one.</li>
</ul>
<p>Plugins can also be added by passing them as arguments when creating
a <code>postcss</code> instance (see [<code>postcss(plugins)</code>]).</p>
<p>Asynchronous plugins should return a <code>Promise</code> instance.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> processor = <span class="code-title function_">postcss</span>()
  .<span class="code-title function_">use</span>(autoprefixer)
  .<span class="code-title function_">use</span>(postcssNested)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>plugin</code></td><td><a href="#acceptedplugin">AcceptedPlugin</a></td><td>PostCSS plugin or <code><a href="#processor">Processor</a></code> with plugins.</td></tr></table><p>Returns <code><a href="#processor">Processor</a></code>. </p><h2 id="processor-version" class="doc_subtitle"><span class="doc_prefix">Processor#</span>version</h2><p>Current PostCSS version.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (result.<span class="code-property">processor</span>.<span class="code-property">version</span>.<span class="code-title function_">split</span>(<span class="code-string">'.'</span>)[<span class="code-number">0</span>] !== <span class="code-string">'6'</span>) {
  <span class="code-keyword">throw</span> <span class="code-keyword">new</span> <span class="code-title class_">Error</span>(<span class="code-string">'This plugin works only with PostCSS 6'</span>)
}
</code></pre><p>Type: string.</p></section><section class="doc"><h1 id="range" class="doc_title">Range</h1><h2 id="range-end" class="doc_subtitle"><span class="doc_prefix">Range#</span>end</h2><p>End position, exclusive.</p><p>Type: <a href="#position">Position</a>.</p><h2 id="range-start" class="doc_subtitle"><span class="doc_prefix">Range#</span>start</h2><p>Start position, inclusive.</p><p>Type: <a href="#position">Position</a>.</p></section><section class="doc"><h1 id="rangeposition" class="doc_title">RangePosition</h1><h2 id="rangeposition-column" class="doc_subtitle"><span class="doc_prefix">RangePosition#</span>column</h2><p>The column number in the input.</p><p>Type: number.</p><h2 id="rangeposition-line" class="doc_subtitle"><span class="doc_prefix">RangePosition#</span>line</h2><p>The line number in the input.</p><p>Type: number.</p></section><section class="doc"><h1 id="result" class="doc_title">Result</h1><h2 id="result-css" class="doc_subtitle"><span class="doc_prefix">Result#</span>css</h2><p>A CSS string representing of <code><a href="#result-root">Result#root</a></code>.</p>
<pre><code class="code language-js">postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{}'</span>).<span class="code-title function_">toResult</span>().<span class="code-property">css</span> <span class="code-comment">//=> "a{}"</span>
</code></pre><p>Type: string.</p><h2 id="result-lastplugin" class="doc_subtitle"><span class="doc_prefix">Result#</span>lastPlugin</h2><p>Last runned PostCSS plugin.</p><p>Type: <a href="#plugin">Plugin</a> | <a href="#transformcallback">TransformCallback</a>.</p><h2 id="result-map" class="doc_subtitle"><span class="doc_prefix">Result#</span>map</h2><p>An instance of <code>SourceMapGenerator</code> class from the <code>source-map</code> library,
representing changes to the <code><a href="#result-root">Result#root</a></code> instance.</p>
<pre><code class="code language-js">result.<span class="code-property">map</span>.<span class="code-title function_">toJSON</span>() <span class="code-comment">//=> { version: 3, file: 'a.css', … }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (result.<span class="code-property">map</span>) {
  fs.<span class="code-title function_">writeFileSync</span>(result.<span class="code-property">opts</span>.<span class="code-property">to</span> + <span class="code-string">'.map'</span>, result.<span class="code-property">map</span>.<span class="code-title function_">toString</span>())
}
</code></pre><p>Type: <a href="#sourcemap">SourceMap</a>.</p><h2 id="result-messages" class="doc_subtitle"><span class="doc_prefix">Result#</span>messages</h2><p>Contains messages from plugins (e.g., warnings or custom messages).
Each message should have type and plugin properties.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">import</span>: (atRule, { result }) {
    <span class="code-keyword">const</span> importedFile = <span class="code-title function_">parseImport</span>(atRule)
    result.<span class="code-property">messages</span>.<span class="code-title function_">push</span>({
      <span class="code-attr">type</span>: <span class="code-string">'dependency'</span>,
      <span class="code-attr">plugin</span>: <span class="code-string">'postcss-import'</span>,
      <span class="code-attr">file</span>: importedFile,
      <span class="code-attr">parent</span>: result.<span class="code-property">opts</span>.<span class="code-property">from</span>
    })
  }
}
</code></pre><p>Type: <a href="#message">Message</a>[].</p><h2 id="result-opts" class="doc_subtitle"><span class="doc_prefix">Result#</span>opts</h2><p>Options from the <code><a href="#processor-process">Processor#process</a></code> or <code><a href="#root-toresult">Root#toResult</a></code> call
that produced this Result instance.]</p>
<pre><code class="code language-js">root.<span class="code-title function_">toResult</span>(opts).<span class="code-property">opts</span> === opts
</code></pre><p>Type: <a href="#resultoptions">ResultOptions</a>.</p><h2 id="result-processor" class="doc_subtitle"><span class="doc_prefix">Result#</span>processor</h2><p>The Processor instance used for this transformation.</p>
<pre><code class="code language-js"><span class="code-keyword">for</span> (<span class="code-keyword">const</span> plugin <span class="code-keyword">of</span> result.<span class="code-property">processor</span>.<span class="code-property">plugins</span>) {
  <span class="code-keyword">if</span> (plugin.<span class="code-property">postcssPlugin</span> === <span class="code-string">'postcss-bad'</span>) {
    <span class="code-keyword">throw</span> <span class="code-string">'postcss-good is incompatible with postcss-bad'</span>
  }
})
</code></pre><p>Type: <a href="#processor">Processor</a>.</p><h2 id="result-root" class="doc_subtitle"><span class="doc_prefix">Result#</span>root</h2><p>Root node after all transformations.</p>
<pre><code class="code language-js">root.<span class="code-title function_">toResult</span>().<span class="code-property">root</span> === root
</code></pre><p>Type: RootNode.</p><h2 id="result-tostring" class="doc_subtitle"><span class="doc_prefix">Result#</span>toString()</h2><p>Returns for <code><a href="#result-css">Result#css</a></code> content.</p>
<pre><code class="code language-js">result + <span class="code-string">''</span> === result.<span class="code-property">css</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="result-warn" class="doc_subtitle"><span class="doc_prefix">Result#</span>warn()</h2><p>Creates an instance of <code><a href="#warning">Warning</a></code> and adds it to <code><a href="#result-messages">Result#messages</a></code>.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">important</span>) {
  result.<span class="code-title function_">warn</span>(<span class="code-string">'Avoid !important'</span>, { <span class="code-attr">node</span>: decl, <span class="code-attr">word</span>: <span class="code-string">'!important'</span> })
}
</code></pre><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p><h2 id="result-warnings" class="doc_subtitle"><span class="doc_prefix">Result#</span>warnings()</h2><p>Returns warnings from plugins. Filters <code><a href="#warning">Warning</a></code> instances
from <code><a href="#result-messages">Result#messages</a></code>.</p>
<pre><code class="code language-js">result.<span class="code-title function_">warnings</span>().<span class="code-title function_">forEach</span>(<span class="code-function"><span class="code-params">warn</span> =></span> {
  <span class="code-variable language_">console</span>.<span class="code-title function_">warn</span>(warn.<span class="code-title function_">toString</span>())
})
</code></pre><p>Returns <code><a href="#warning">Warning</a>[]</code>. </p></section><section class="doc"><h1 id="resultoptions" class="doc_title">ResultOptions</h1><h2 id="resultoptions-document" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>document</h2><p>Input file if it is not simple CSS file, but HTML with  or JS with CSS-in-JS blocks.</p><p>Type: string.</p><h2 id="resultoptions-from" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>from</h2><p>The path of the CSS source file. You should always set <code>from</code>,
because it is used in source map generation and syntax error messages.</p><p>Type: string.</p><h2 id="resultoptions-map" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>map</h2><p>Source map options</p><p>Type: boolean | <a href="#sourcemapoptions">SourceMapOptions</a>.</p><h2 id="resultoptions-node" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>node</h2><p>The CSS node that was the source of the warning.</p><p>Type: <a href="#node">Node</a>.</p><h2 id="resultoptions-parser" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>parser</h2><p>Function to generate AST by string.</p><p>Type: <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>> | <a href="#parser">Parser</a>&lt;Document_ | <a href="#root">Root</a>>.</p><h2 id="resultoptions-plugin" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>plugin</h2><p>Name of plugin that created this warning. <code><a href="#result-warn">Result#warn</a></code> will fill it
automatically with <code><a href="#plugin-postcssplugin">Plugin#postcssPlugin</a></code> value.</p><p>Type: string.</p><h2 id="resultoptions-stringifier" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>stringifier</h2><p>Class to generate string by AST.</p><p>Type: <a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>>.</p><h2 id="resultoptions-syntax" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>syntax</h2><p>Object with parse and stringify.</p><p>Type: <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>>.</p><h2 id="resultoptions-to" class="doc_subtitle"><span class="doc_prefix">ResultOptions#</span>to</h2><p>The path where you'll put the output CSS file. You should always set <code>to</code>
to generate correct source maps.</p><p>Type: string.</p></section><section class="doc"><h1 id="root" class="doc_title">Root</h1><h2 id="root-after" class="doc_subtitle"><span class="doc_prefix">Root#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-append" class="doc_subtitle"><span class="doc_prefix">Root#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-assign" class="doc_subtitle"><span class="doc_prefix">Root#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#rootprops">RootProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-before" class="doc_subtitle"><span class="doc_prefix">Root#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-cleanraws" class="doc_subtitle"><span class="doc_prefix">Root#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="root-clone" class="doc_subtitle"><span class="doc_prefix">Root#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#rootprops">RootProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-cloneafter" class="doc_subtitle"><span class="doc_prefix">Root#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#rootprops">RootProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-clonebefore" class="doc_subtitle"><span class="doc_prefix">Root#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#rootprops">RootProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-each" class="doc_subtitle"><span class="doc_prefix">Root#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-error" class="doc_subtitle"><span class="doc_prefix">Root#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="root-every" class="doc_subtitle"><span class="doc_prefix">Root#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="root-index" class="doc_subtitle"><span class="doc_prefix">Root#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="root-insertafter" class="doc_subtitle"><span class="doc_prefix">Root#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-insertbefore" class="doc_subtitle"><span class="doc_prefix">Root#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-markdirty" class="doc_subtitle"><span class="doc_prefix">Root#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="root-next" class="doc_subtitle"><span class="doc_prefix">Root#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="root-nodes" class="doc_subtitle"><span class="doc_prefix">Root#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="root-parent" class="doc_subtitle"><span class="doc_prefix">Root#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Document_.</p><h2 id="root-positionby" class="doc_subtitle"><span class="doc_prefix">Root#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="root-positioninside" class="doc_subtitle"><span class="doc_prefix">Root#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="root-prepend" class="doc_subtitle"><span class="doc_prefix">Root#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-prev" class="doc_subtitle"><span class="doc_prefix">Root#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="root-push" class="doc_subtitle"><span class="doc_prefix">Root#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-rangeby" class="doc_subtitle"><span class="doc_prefix">Root#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="root-raw" class="doc_subtitle"><span class="doc_prefix">Root#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="root-raws" class="doc_subtitle"><span class="doc_prefix">Root#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#rootraws">RootRaws</a>.</p><h2 id="root-remove" class="doc_subtitle"><span class="doc_prefix">Root#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-removeall" class="doc_subtitle"><span class="doc_prefix">Root#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-removechild" class="doc_subtitle"><span class="doc_prefix">Root#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-replacevalues" class="doc_subtitle"><span class="doc_prefix">Root#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-replacewith" class="doc_subtitle"><span class="doc_prefix">Root#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-root" class="doc_subtitle"><span class="doc_prefix">Root#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="root-some" class="doc_subtitle"><span class="doc_prefix">Root#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="root-source" class="doc_subtitle"><span class="doc_prefix">Root#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="root-tojson" class="doc_subtitle"><span class="doc_prefix">Root#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="root-toresult" class="doc_subtitle"><span class="doc_prefix">Root#</span>toResult()</h2><p>Returns a <code><a href="#result">Result</a></code> instance representing the root’s CSS.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root1 = postcss.<span class="code-title function_">parse</span>(css1, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span> })
<span class="code-keyword">const</span> root2 = postcss.<span class="code-title function_">parse</span>(css2, { <span class="code-attr">from</span>: <span class="code-string">'b.css'</span> })
root1.<span class="code-title function_">append</span>(root2)
<span class="code-keyword">const</span> result = root1.<span class="code-title function_">toResult</span>({ <span class="code-attr">to</span>: <span class="code-string">'all.css'</span>, <span class="code-attr">map</span>: <span class="code-literal">true</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a>&lt;Document_ | <a href="#root">Root</a>></td><td>Options.</td></tr></table><p>Returns <code><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></code>. </p><h2 id="root-tostring" class="doc_subtitle"><span class="doc_prefix">Root#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="root-type" class="doc_subtitle"><span class="doc_prefix">Root#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "root".</p><h2 id="root-walk" class="doc_subtitle"><span class="doc_prefix">Root#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkatrules" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkcomments" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkdecls" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-walkrules" class="doc_subtitle"><span class="doc_prefix">Root#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="root-warn" class="doc_subtitle"><span class="doc_prefix">Root#</span>warn()</h2><p>It is a wrapper for warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="rootprops" class="doc_title">RootProps</h1><h2 id="rootprops-nodes" class="doc_subtitle"><span class="doc_prefix">RootProps#</span>nodes</h2><p>Type: readonly (<a href="#node">Node</a> | <a href="#childprops">ChildProps</a>)[].</p><h2 id="rootprops-raws" class="doc_subtitle"><span class="doc_prefix">RootProps#</span>raws</h2><p>Information used to generate byte-to-byte equal node string
as it was in the origin input.</p><p>Type: <a href="#rootraws">RootRaws</a>.</p><h2 id="rootprops-source" class="doc_subtitle"><span class="doc_prefix">RootProps#</span>source</h2><p>Type: <a href="#source">Source</a>.</p></section><section class="doc"><h1 id="rootprops" class="doc_title">RootProps</h1><h2 id="rootprops-nodes" class="doc_subtitle"><span class="doc_prefix">RootProps#</span>nodes</h2><p>Type: readonly (<a href="#node">Node</a> | <a href="#childprops">ChildProps</a>)[].</p><h2 id="rootprops-raws" class="doc_subtitle"><span class="doc_prefix">RootProps#</span>raws</h2><p>Information used to generate byte-to-byte equal node string
as it was in the origin input.</p><p>Type: <a href="#rootraws">RootRaws</a>.</p><h2 id="rootprops-source" class="doc_subtitle"><span class="doc_prefix">RootProps#</span>source</h2><p>Type: <a href="#source">Source</a>.</p></section><section class="doc"><h1 id="rootraws" class="doc_title">RootRaws</h1><h2 id="rootraws-after" class="doc_subtitle"><span class="doc_prefix">RootRaws#</span>after</h2><p>The space symbols after the last child to the end of file.</p><p>Type: string.</p><h2 id="rootraws-codeafter" class="doc_subtitle"><span class="doc_prefix">RootRaws#</span>codeAfter</h2><p>Non-CSS code after <code><a href="#root">Root</a></code>, when <code><a href="#root">Root</a></code> is inside <code><a href="#document">Document</a></code>.</p>
<p><strong>Experimental:</strong> some aspects of this node could change within minor
or patch version releases.</p><p>Type: string.</p><h2 id="rootraws-codebefore" class="doc_subtitle"><span class="doc_prefix">RootRaws#</span>codeBefore</h2><p>Non-CSS code before <code><a href="#root">Root</a></code>, when <code><a href="#root">Root</a></code> is inside <code><a href="#document">Document</a></code>.</p>
<p><strong>Experimental:</strong> some aspects of this node could change within minor
or patch version releases.</p><p>Type: string.</p><h2 id="rootraws-semicolon" class="doc_subtitle"><span class="doc_prefix">RootRaws#</span>semicolon</h2><p>Is the last child has an (optional) semicolon.</p><p>Type: boolean.</p></section><section class="doc"><h1 id="rule" class="doc_title">Rule</h1><h2 id="rule-after" class="doc_subtitle"><span class="doc_prefix">Rule#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-append" class="doc_subtitle"><span class="doc_prefix">Rule#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-assign" class="doc_subtitle"><span class="doc_prefix">Rule#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#ruleprops">RuleProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-before" class="doc_subtitle"><span class="doc_prefix">Rule#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-cleanraws" class="doc_subtitle"><span class="doc_prefix">Rule#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="rule-clone" class="doc_subtitle"><span class="doc_prefix">Rule#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-cloneafter" class="doc_subtitle"><span class="doc_prefix">Rule#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-clonebefore" class="doc_subtitle"><span class="doc_prefix">Rule#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-each" class="doc_subtitle"><span class="doc_prefix">Rule#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-error" class="doc_subtitle"><span class="doc_prefix">Rule#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="rule-every" class="doc_subtitle"><span class="doc_prefix">Rule#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="rule-index" class="doc_subtitle"><span class="doc_prefix">Rule#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="rule-insertafter" class="doc_subtitle"><span class="doc_prefix">Rule#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-insertbefore" class="doc_subtitle"><span class="doc_prefix">Rule#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-markdirty" class="doc_subtitle"><span class="doc_prefix">Rule#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="rule-next" class="doc_subtitle"><span class="doc_prefix">Rule#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="rule-nodes" class="doc_subtitle"><span class="doc_prefix">Rule#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="rule-parent" class="doc_subtitle"><span class="doc_prefix">Rule#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: <a href="#containerwithchildren">ContainerWithChildren</a>.</p><h2 id="rule-positionby" class="doc_subtitle"><span class="doc_prefix">Rule#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="rule-positioninside" class="doc_subtitle"><span class="doc_prefix">Rule#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="rule-prepend" class="doc_subtitle"><span class="doc_prefix">Rule#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-prev" class="doc_subtitle"><span class="doc_prefix">Rule#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="rule-push" class="doc_subtitle"><span class="doc_prefix">Rule#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-rangeby" class="doc_subtitle"><span class="doc_prefix">Rule#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="rule-raw" class="doc_subtitle"><span class="doc_prefix">Rule#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="rule-raws" class="doc_subtitle"><span class="doc_prefix">Rule#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#ruleraws">RuleRaws</a>.</p><h2 id="rule-remove" class="doc_subtitle"><span class="doc_prefix">Rule#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-removeall" class="doc_subtitle"><span class="doc_prefix">Rule#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-removechild" class="doc_subtitle"><span class="doc_prefix">Rule#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-replacevalues" class="doc_subtitle"><span class="doc_prefix">Rule#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-replacewith" class="doc_subtitle"><span class="doc_prefix">Rule#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#rule">Rule</a></code>. </p><h2 id="rule-root" class="doc_subtitle"><span class="doc_prefix">Rule#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="rule-some" class="doc_subtitle"><span class="doc_prefix">Rule#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="rule-source" class="doc_subtitle"><span class="doc_prefix">Rule#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="rule-tojson" class="doc_subtitle"><span class="doc_prefix">Rule#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="rule-tostring" class="doc_subtitle"><span class="doc_prefix">Rule#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="rule-type" class="doc_subtitle"><span class="doc_prefix">Rule#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "rule".</p><h2 id="rule-walk" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkatrules" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkcomments" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkdecls" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-walkrules" class="doc_subtitle"><span class="doc_prefix">Rule#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="rule-warn" class="doc_subtitle"><span class="doc_prefix">Rule#</span>warn()</h2><p>It is a wrapper for warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="ruleraws" class="doc_title">RuleRaws</h1><h2 id="ruleraws-after" class="doc_subtitle"><span class="doc_prefix">RuleRaws#</span>after</h2><p>The space symbols after the last child of the node to the end of the node.</p><p>Type: string.</p><h2 id="ruleraws-before" class="doc_subtitle"><span class="doc_prefix">RuleRaws#</span>before</h2><p>The space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</p><p>Type: string.</p><h2 id="ruleraws-between" class="doc_subtitle"><span class="doc_prefix">RuleRaws#</span>between</h2><p>The symbols between the selector and <code>{</code> for rules.</p><p>Type: string.</p><h2 id="ruleraws-ownsemicolon" class="doc_subtitle"><span class="doc_prefix">RuleRaws#</span>ownSemicolon</h2><p>Contains the text of the semicolon after this rule.</p><p>Type: string.</p><h2 id="ruleraws-selector" class="doc_subtitle"><span class="doc_prefix">RuleRaws#</span>selector</h2><p>The rule’s selector with comments.</p><p>Type: Object.</p><h2 id="ruleraws-semicolon" class="doc_subtitle"><span class="doc_prefix">RuleRaws#</span>semicolon</h2><p>Contains <code>true</code> if the last child has an (optional) semicolon.</p><p>Type: boolean.</p></section><section class="doc"><h1 id="source" class="doc_title">Source</h1><h2 id="source-end" class="doc_subtitle"><span class="doc_prefix">Source#</span>end</h2><p>The inclusive ending position for the source
code of a node.</p>
<p>However, <code>end.offset</code> of a non <code><a href="#root">Root</a></code> node is the exclusive position.
See <a href="https://github.com/postcss/postcss/pull/1879">https://github.com/postcss/postcss/pull/1879</a> for details.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
<span class="code-keyword">const</span> a = root.<span class="code-property">first</span>
<span class="code-keyword">const</span> color = a.<span class="code-property">first</span>

<span class="code-comment">// The offset of `Root` node is the inclusive position</span>
css.<span class="code-property">source</span>.<span class="code-property">end</span>   <span class="code-comment">// { line: 1, column: 19, offset: 18 }</span>

<span class="code-comment">// The offset of non `Root` node is the exclusive position</span>
a.<span class="code-property">source</span>.<span class="code-property">end</span>     <span class="code-comment">// { line: 1, column: 18, offset: 18 }</span>
color.<span class="code-property">source</span>.<span class="code-property">end</span> <span class="code-comment">// { line: 1, column: 16, offset: 16 }</span>
</code></pre><p>Type: <a href="#position">Position</a>.</p><h2 id="source-input" class="doc_subtitle"><span class="doc_prefix">Source#</span>input</h2><p>The source file from where a node has originated.</p><p>Type: Input_.</p><h2 id="source-start" class="doc_subtitle"><span class="doc_prefix">Source#</span>start</h2><p>The inclusive starting position for the source
code of a node.</p><p>Type: <a href="#position">Position</a>.</p></section><section class="doc"><h1 id="sourcemapoptions" class="doc_title">SourceMapOptions</h1><h2 id="sourcemapoptions-absolute" class="doc_subtitle"><span class="doc_prefix">SourceMapOptions#</span>absolute</h2><p>Use absolute path in generated source map.</p><p>Type: boolean.</p><h2 id="sourcemapoptions-annotation" class="doc_subtitle"><span class="doc_prefix">SourceMapOptions#</span>annotation</h2><p>Indicates that PostCSS should add annotation comments to the CSS.
By default, PostCSS will always add a comment with a path
to the source map. PostCSS will not add annotations to CSS files
that do not contain any comments.</p>
<p>By default, PostCSS presumes that you want to save the source map as
<code>opts.to + '.map'</code> and will use this path in the annotation comment.
A different path can be set by providing a string value for annotation.</p>
<p>If you have set <code>inline: true</code>, annotation cannot be disabled.</p><p>Type: string | boolean | Function.</p><h2 id="sourcemapoptions-from" class="doc_subtitle"><span class="doc_prefix">SourceMapOptions#</span>from</h2><p>Override <code>from</code> in map’s sources.</p><p>Type: string.</p><h2 id="sourcemapoptions-inline" class="doc_subtitle"><span class="doc_prefix">SourceMapOptions#</span>inline</h2><p>Indicates that the source map should be embedded in the output CSS
as a Base64-encoded comment. By default, it is <code>true</code>.
But if all previous maps are external, not inline, PostCSS will not embed
the map even if you do not set this option.</p>
<p>If you have an inline source map, the result.map property will be empty,
as the source map will be contained within the text of <code>result.css</code>.</p><p>Type: boolean.</p><h2 id="sourcemapoptions-prev" class="doc_subtitle"><span class="doc_prefix">SourceMapOptions#</span>prev</h2><p>Source map content from a previous processing step (e.g., Sass).</p>
<p>PostCSS will try to read the previous source map
automatically (based on comments within the source CSS), but you can use
this option to identify it manually.</p>
<p>If desired, you can omit the previous map with prev: <code>false</code>.</p><p>Type: string | boolean | object | Function.</p><h2 id="sourcemapoptions-sourcescontent" class="doc_subtitle"><span class="doc_prefix">SourceMapOptions#</span>sourcesContent</h2><p>Indicates that PostCSS should set the origin content (e.g., Sass source)
of the source map. By default, it is true. But if all previous maps do not
contain sources content, PostCSS will also leave it out even if you
do not set this option.</p><p>Type: boolean.</p></section><section class="doc"><h1 id="syntax" class="doc_title">Syntax</h1><h2 id="syntax-parse" class="doc_subtitle"><span class="doc_prefix">Syntax#</span>parse</h2><p>Function to generate AST by string.</p><p>Type: <a href="#parser">Parser</a>&lt;RootNode>.</p><h2 id="syntax-stringify" class="doc_subtitle"><span class="doc_prefix">Syntax#</span>stringify</h2><p>Class to generate string by AST.</p><p>Type: <a href="#stringifier">Stringifier</a>.</p></section><section class="doc"><h1 id="transformer" class="doc_title">Transformer</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td></tr></table><p>Returns <code>void | Promise&lt;void></code>. </p><h2 id="transformer-postcssplugin" class="doc_subtitle"><span class="doc_prefix">Transformer#</span>postcssPlugin</h2><p>Type: string.</p><h2 id="transformer-postcssversion" class="doc_subtitle"><span class="doc_prefix">Transformer#</span>postcssVersion</h2><p>Type: string.</p></section><section class="doc"><h1 id="valueoptions" class="doc_title">ValueOptions</h1><h2 id="valueoptions-fast" class="doc_subtitle"><span class="doc_prefix">ValueOptions#</span>fast</h2><p>String that’s used to narrow down values and speed up the regexp search.</p><p>Type: string.</p><h2 id="valueoptions-props" class="doc_subtitle"><span class="doc_prefix">ValueOptions#</span>props</h2><p>An array of property names.</p><p>Type: readonly string[].</p></section><section class="doc"><h1 id="warning" class="doc_title">Warning</h1><h2 id="warning-column" class="doc_subtitle"><span class="doc_prefix">Warning#</span>column</h2><p>Column for inclusive start position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">column</span> <span class="code-comment">//=> 6</span>
</code></pre><p>Type: number.</p><h2 id="warning-endcolumn" class="doc_subtitle"><span class="doc_prefix">Warning#</span>endColumn</h2><p>Column for exclusive end position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">endColumn</span> <span class="code-comment">//=> 4</span>
</code></pre><p>Type: number.</p><h2 id="warning-endline" class="doc_subtitle"><span class="doc_prefix">Warning#</span>endLine</h2><p>Line for exclusive end position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">endLine</span> <span class="code-comment">//=> 6</span>
</code></pre><p>Type: number.</p><h2 id="warning-line" class="doc_subtitle"><span class="doc_prefix">Warning#</span>line</h2><p>Line for inclusive start position in the input file with this warning’s source.</p>
<pre><code class="code language-js">warning.<span class="code-property">line</span> <span class="code-comment">//=> 5</span>
</code></pre><p>Type: number.</p><h2 id="warning-node" class="doc_subtitle"><span class="doc_prefix">Warning#</span>node</h2><p>Contains the CSS node that caused the warning.</p>
<pre><code class="code language-js">warning.<span class="code-property">node</span>.<span class="code-title function_">toString</span>() <span class="code-comment">//=> 'color: white !important'</span>
</code></pre><p>Type: <a href="#node">Node</a>.</p><h2 id="warning-plugin" class="doc_subtitle"><span class="doc_prefix">Warning#</span>plugin</h2><p>The name of the plugin that created this warning.
When you call <code><a href="#node-warn">Node#warn</a></code> it will fill this property automatically.</p>
<pre><code class="code language-js">warning.<span class="code-property">plugin</span> <span class="code-comment">//=> 'postcss-important'</span>
</code></pre><p>Type: string.</p><h2 id="warning-text" class="doc_subtitle"><span class="doc_prefix">Warning#</span>text</h2><p>The warning message.</p>
<pre><code class="code language-js">warning.<span class="code-property">text</span> <span class="code-comment">//=> 'Try to avoid !important'</span>
</code></pre><p>Type: string.</p><h2 id="warning-tostring" class="doc_subtitle"><span class="doc_prefix">Warning#</span>toString()</h2><p>Returns a warning position and message.</p>
<pre><code class="code language-js">warning.<span class="code-title function_">toString</span>() <span class="code-comment">//=> 'postcss-lint:a.css:10:14: Avoid !important'</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="warning-type" class="doc_subtitle"><span class="doc_prefix">Warning#</span>type</h2><p>Type to filter warnings from <code><a href="#result-messages">Result#messages</a></code>.
Always equal to <code>"warning"</code>.</p><p>Type: "warning".</p></section><section class="doc"><h1 id="warningoptions" class="doc_title">WarningOptions</h1><h2 id="warningoptions-end" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>end</h2><p>End position, exclusive, in CSS node string that caused the warning.</p><p>Type: <a href="#rangeposition">RangePosition</a>.</p><h2 id="warningoptions-endindex" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>endIndex</h2><p>End index, exclusive, in CSS node string that caused the warning.</p><p>Type: number.</p><h2 id="warningoptions-index" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>index</h2><p>Start index, inclusive, in CSS node string that caused the warning.</p><p>Type: number.</p><h2 id="warningoptions-node" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>node</h2><p>CSS node that caused the warning.</p><p>Type: <a href="#node">Node</a>.</p><h2 id="warningoptions-plugin" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>plugin</h2><p>Name of the plugin that created this warning. <code><a href="#result-warn">Result#warn</a></code> fills
this property automatically.</p><p>Type: string.</p><h2 id="warningoptions-start" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>start</h2><p>Start position, inclusive, in CSS node string that caused the warning.</p><p>Type: <a href="#rangeposition">RangePosition</a>.</p><h2 id="warningoptions-word" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>word</h2><p>Word in CSS source that caused the warning.</p><p>Type: string.</p></section><section class="doc"><h1 id="warningoptions" class="doc_title">WarningOptions</h1><h2 id="warningoptions-end" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>end</h2><p>End position, exclusive, in CSS node string that caused the warning.</p><p>Type: <a href="#rangeposition">RangePosition</a>.</p><h2 id="warningoptions-endindex" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>endIndex</h2><p>End index, exclusive, in CSS node string that caused the warning.</p><p>Type: number.</p><h2 id="warningoptions-index" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>index</h2><p>Start index, inclusive, in CSS node string that caused the warning.</p><p>Type: number.</p><h2 id="warningoptions-node" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>node</h2><p>CSS node that caused the warning.</p><p>Type: <a href="#node">Node</a>.</p><h2 id="warningoptions-plugin" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>plugin</h2><p>Name of the plugin that created this warning. <code><a href="#result-warn">Result#warn</a></code> fills
this property automatically.</p><p>Type: string.</p><h2 id="warningoptions-start" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>start</h2><p>Start position, inclusive, in CSS node string that caused the warning.</p><p>Type: <a href="#rangeposition">RangePosition</a>.</p><h2 id="warningoptions-word" class="doc_subtitle"><span class="doc_prefix">WarningOptions#</span>word</h2><p>Word in CSS source that caused the warning.</p><p>Type: string.</p></section><section class="doc"><h1 id="at-rule" class="doc_title">at-rule</h1><h2 id="at-rule-after" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-append" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-assign" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#atruleprops">AtRuleProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-before" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-cleanraws" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="at-rule-clone" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-cloneafter" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-clonebefore" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-each" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="at-rule-error" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="at-rule-every" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="at-rule-index" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="at-rule-insertafter" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-insertbefore" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-markdirty" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="at-rule-next" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="at-rule-nodes" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>nodes</h2><p>An array containing the layer’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'@layer example { a { color: black } }'</span>)
<span class="code-keyword">const</span> layer = root.<span class="code-property">first</span>
layer.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
layer.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
</code></pre>
<p>Can be <code>undefinded</code> if the at-rule has no body.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'@layer a, b, c;'</span>)
<span class="code-keyword">const</span> layer = root.<span class="code-property">first</span>
layer.<span class="code-property">nodes</span> <span class="code-comment">//=> undefined</span>
</code></pre><p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="at-rule-parent" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: <a href="#containerwithchildren">ContainerWithChildren</a>.</p><h2 id="at-rule-positionby" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="at-rule-positioninside" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="at-rule-prepend" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-prev" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="at-rule-push" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-rangeby" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="at-rule-raw" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="at-rule-raws" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#atruleraws">AtRuleRaws</a>.</p><h2 id="at-rule-remove" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-removeall" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-removechild" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#childnode">ChildNode</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-replacevalues" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-replacewith" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code>AtRule_</code>. </p><h2 id="at-rule-root" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="at-rule-some" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="at-rule-source" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="at-rule-tojson" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="at-rule-tostring" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="at-rule-type" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "atrule".</p><h2 id="at-rule-walk" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="at-rule-walkatrules" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="at-rule-walkcomments" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="at-rule-walkdecls" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="at-rule-walkrules" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="at-rule-warn" class="doc_subtitle"><span class="doc_prefix">at-rule#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="comment" class="doc_title">comment</h1><h2 id="comment-after" class="doc_subtitle"><span class="doc_prefix">comment#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="comment-assign" class="doc_subtitle"><span class="doc_prefix">comment#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#commentprops">CommentProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="comment-before" class="doc_subtitle"><span class="doc_prefix">comment#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="comment-cleanraws" class="doc_subtitle"><span class="doc_prefix">comment#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="comment-clone" class="doc_subtitle"><span class="doc_prefix">comment#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="comment-cloneafter" class="doc_subtitle"><span class="doc_prefix">comment#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="comment-clonebefore" class="doc_subtitle"><span class="doc_prefix">comment#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="comment-error" class="doc_subtitle"><span class="doc_prefix">comment#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="comment-markdirty" class="doc_subtitle"><span class="doc_prefix">comment#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="comment-next" class="doc_subtitle"><span class="doc_prefix">comment#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="comment-parent" class="doc_subtitle"><span class="doc_prefix">comment#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Container_&lt;<a href="#childnode">ChildNode</a>>.</p><h2 id="comment-positionby" class="doc_subtitle"><span class="doc_prefix">comment#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="comment-positioninside" class="doc_subtitle"><span class="doc_prefix">comment#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="comment-prev" class="doc_subtitle"><span class="doc_prefix">comment#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="comment-rangeby" class="doc_subtitle"><span class="doc_prefix">comment#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="comment-raw" class="doc_subtitle"><span class="doc_prefix">comment#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="comment-raws" class="doc_subtitle"><span class="doc_prefix">comment#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#commentraws">CommentRaws</a>.</p><h2 id="comment-remove" class="doc_subtitle"><span class="doc_prefix">comment#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code>Comment_</code>. </p><h2 id="comment-replacewith" class="doc_subtitle"><span class="doc_prefix">comment#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code>Comment_</code>. </p><h2 id="comment-root" class="doc_subtitle"><span class="doc_prefix">comment#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="comment-source" class="doc_subtitle"><span class="doc_prefix">comment#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="comment-tojson" class="doc_subtitle"><span class="doc_prefix">comment#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="comment-tostring" class="doc_subtitle"><span class="doc_prefix">comment#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="comment-type" class="doc_subtitle"><span class="doc_prefix">comment#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "comment".</p><h2 id="comment-warn" class="doc_subtitle"><span class="doc_prefix">comment#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="container" class="doc_title">container</h1><h2 id="container-after" class="doc_subtitle"><span class="doc_prefix">container#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-append" class="doc_subtitle"><span class="doc_prefix">container#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-assign" class="doc_subtitle"><span class="doc_prefix">container#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#containerprops">ContainerProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-before" class="doc_subtitle"><span class="doc_prefix">container#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-cleanraws" class="doc_subtitle"><span class="doc_prefix">container#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="container-clone" class="doc_subtitle"><span class="doc_prefix">container#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#containerprops">ContainerProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-cloneafter" class="doc_subtitle"><span class="doc_prefix">container#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#containerprops">ContainerProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-clonebefore" class="doc_subtitle"><span class="doc_prefix">container#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#containerprops">ContainerProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-each" class="doc_subtitle"><span class="doc_prefix">container#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-error" class="doc_subtitle"><span class="doc_prefix">container#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="container-every" class="doc_subtitle"><span class="doc_prefix">container#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="container-index" class="doc_subtitle"><span class="doc_prefix">container#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | Child</td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="container-insertafter" class="doc_subtitle"><span class="doc_prefix">container#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | Child</td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-insertbefore" class="doc_subtitle"><span class="doc_prefix">container#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | Child</td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-markdirty" class="doc_subtitle"><span class="doc_prefix">container#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="container-next" class="doc_subtitle"><span class="doc_prefix">container#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="container-nodes" class="doc_subtitle"><span class="doc_prefix">container#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: Child[].</p><h2 id="container-parent" class="doc_subtitle"><span class="doc_prefix">container#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Container_&lt;<a href="#childnode">ChildNode</a>> | Document_.</p><h2 id="container-positionby" class="doc_subtitle"><span class="doc_prefix">container#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="container-positioninside" class="doc_subtitle"><span class="doc_prefix">container#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="container-prepend" class="doc_subtitle"><span class="doc_prefix">container#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-prev" class="doc_subtitle"><span class="doc_prefix">container#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="container-push" class="doc_subtitle"><span class="doc_prefix">container#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>Child</td><td>New node.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-rangeby" class="doc_subtitle"><span class="doc_prefix">container#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="container-raw" class="doc_subtitle"><span class="doc_prefix">container#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="container-raws" class="doc_subtitle"><span class="doc_prefix">container#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: any.</p><h2 id="container-remove" class="doc_subtitle"><span class="doc_prefix">container#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-removeall" class="doc_subtitle"><span class="doc_prefix">container#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-removechild" class="doc_subtitle"><span class="doc_prefix">container#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | Child</td><td>Child or child’s index.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-replacevalues" class="doc_subtitle"><span class="doc_prefix">container#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-replacewith" class="doc_subtitle"><span class="doc_prefix">container#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code>Container_&lt;Child></code>. </p><h2 id="container-root" class="doc_subtitle"><span class="doc_prefix">container#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="container-some" class="doc_subtitle"><span class="doc_prefix">container#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="container-source" class="doc_subtitle"><span class="doc_prefix">container#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="container-tojson" class="doc_subtitle"><span class="doc_prefix">container#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="container-tostring" class="doc_subtitle"><span class="doc_prefix">container#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="container-type" class="doc_subtitle"><span class="doc_prefix">container#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: string.</p><h2 id="container-walk" class="doc_subtitle"><span class="doc_prefix">container#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkatrules" class="doc_subtitle"><span class="doc_prefix">container#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkcomments" class="doc_subtitle"><span class="doc_prefix">container#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkdecls" class="doc_subtitle"><span class="doc_prefix">container#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-walkrules" class="doc_subtitle"><span class="doc_prefix">container#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="container-warn" class="doc_subtitle"><span class="doc_prefix">container#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="css-syntax-error" class="doc_title">css-syntax-error</h1><h2 id="css-syntax-error-capturestacktrace" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>captureStackTrace()</h2><p>Create .stack property on a target object</p><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>targetObject</code></td><td>object</td></tr><tr><td><code>constructorOpt</code></td><td>Function</td></tr></table><h2 id="css-syntax-error-column" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>column</h2><p>Source column of the error.</p>
<pre><code class="code language-js">error.<span class="code-property">column</span>       <span class="code-comment">//=> 1</span>
error.<span class="code-property">input</span>.<span class="code-property">column</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.column</code>.</p><p>Type: number.</p><h2 id="css-syntax-error-endcolumn" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>endColumn</h2><p>Source column of the error's end, exclusive. Provided if the error pertains
to a range.</p>
<pre><code class="code language-js">error.<span class="code-property">endColumn</span>       <span class="code-comment">//=> 1</span>
error.<span class="code-property">input</span>.<span class="code-property">endColumn</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.endColumn</code>.</p><p>Type: number.</p><h2 id="css-syntax-error-endline" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>endLine</h2><p>Source line of the error's end, exclusive. Provided if the error pertains
to a range.</p>
<pre><code class="code language-js">error.<span class="code-property">endLine</span>       <span class="code-comment">//=> 3</span>
error.<span class="code-property">input</span>.<span class="code-property">endLine</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.endLine</code>.</p><p>Type: number.</p><h2 id="css-syntax-error-file" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>file</h2><p>Absolute path to the broken file.</p>
<pre><code class="code language-js">error.<span class="code-property">file</span>       <span class="code-comment">//=> 'a.sass'</span>
error.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> 'a.css'</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.file</code>.</p><p>Type: string.</p><h2 id="css-syntax-error-input" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>input</h2><p>Input object with PostCSS internal information
about input file. If input has source map
from previous tool, PostCSS will use origin
(for example, Sass) source. You can use this
object to get PostCSS input source.</p>
<pre><code class="code language-js">error.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> 'a.css'</span>
error.<span class="code-property">file</span>       <span class="code-comment">//=> 'a.sass'</span>
</code></pre><p>Type: <a href="#fileposition">FilePosition</a>.</p><h2 id="css-syntax-error-line" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>line</h2><p>Source line of the error.</p>
<pre><code class="code language-js">error.<span class="code-property">line</span>       <span class="code-comment">//=> 2</span>
error.<span class="code-property">input</span>.<span class="code-property">line</span> <span class="code-comment">//=> 4</span>
</code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.line</code>.</p><p>Type: number.</p><h2 id="css-syntax-error-message" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>message</h2><p>Full error text in the GNU error format
with plugin, file, line and column.</p>
<pre><code class="code language-js">error.<span class="code-property">message</span> <span class="code-comment">//=> 'a.css:1:1: Unclosed block'</span>
</code></pre><p>Type: string.</p><h2 id="css-syntax-error-name" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>name</h2><p>Always equal to <code>'CssSyntaxError'</code>. You should always check error type
by <code>error.name === 'CssSyntaxError'</code>
instead of <code>error instanceof CssSyntaxError</code>,
because npm could have several PostCSS versions.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (error.<span class="code-property">name</span> === <span class="code-string">'CssSyntaxError'</span>) {
  error <span class="code-comment">//=> CssSyntaxError</span>
}
</code></pre><p>Type: "<a href="#csssyntaxerror">CssSyntaxError</a>".</p><h2 id="css-syntax-error-plugin" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>plugin</h2><p>Plugin name, if error came from plugin.</p>
<pre><code class="code language-js">error.<span class="code-property">plugin</span> <span class="code-comment">//=> 'postcss-vars'</span>
</code></pre><p>Type: string.</p><h2 id="css-syntax-error-preparestacktrace" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>prepareStackTrace</h2><p>Type: Function.</p><h2 id="css-syntax-error-reason" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>reason</h2><p>Error message.</p>
<pre><code class="code language-js">error.<span class="code-property">message</span> <span class="code-comment">//=> 'Unclosed block'</span>
</code></pre><p>Type: string.</p><h2 id="css-syntax-error-showsourcecode" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>showSourceCode()</h2><p>Returns a few lines of CSS source that caused the error.</p>
<p>If the CSS has an input source map without <code>sourceContent</code>,
this method will return an empty string.</p>
<pre><code class="code language-js">error.<span class="code-title function_">showSourceCode</span>() <span class="code-comment">//=> "  4 | }</span>
                       <span class="code-comment">//      5 | a {</span>
                       <span class="code-comment">//    > 6 |   bad</span>
                       <span class="code-comment">//        |   ^</span>
                       <span class="code-comment">//      7 | }</span>
                       <span class="code-comment">//      8 | b {"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>color</code></td><td>boolean</td><td>Whether arrow will be colored red by terminal
color codes. By default, PostCSS will detect
color support by <code>process.stdout.isTTY</code>
and <code>process.env.NODE_DISABLE_COLORS</code>.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="css-syntax-error-source" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>source</h2><p>Source code of the broken file.</p>
<pre><code class="code language-js">error.<span class="code-property">source</span>       <span class="code-comment">//=> 'a { b {} }'</span>
error.<span class="code-property">input</span>.<span class="code-property">source</span> <span class="code-comment">//=> 'a b { }'</span>
</code></pre><p>Type: string.</p><h2 id="css-syntax-error-stack" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>stack</h2><p>Type: string.</p><h2 id="css-syntax-error-stacktracelimit" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>stackTraceLimit</h2><p>Type: number.</p><h2 id="css-syntax-error-tostring" class="doc_subtitle"><span class="doc_prefix">css-syntax-error#</span>toString()</h2><p>Returns error position, message and source code of the broken part.</p>
<pre><code class="code language-js">error.<span class="code-title function_">toString</span>() <span class="code-comment">//=> "CssSyntaxError: app.css:1:1: Unclosed block</span>
                 <span class="code-comment">//    > 1 | a {</span>
                 <span class="code-comment">//        | ^"</span>
</code></pre><p>Returns <code>string</code>. </p></section><section class="doc"><h1 id="declaration" class="doc_title">declaration</h1><h2 id="declaration-after" class="doc_subtitle"><span class="doc_prefix">declaration#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-assign" class="doc_subtitle"><span class="doc_prefix">declaration#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#declarationprops">DeclarationProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-before" class="doc_subtitle"><span class="doc_prefix">declaration#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-cleanraws" class="doc_subtitle"><span class="doc_prefix">declaration#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="declaration-clone" class="doc_subtitle"><span class="doc_prefix">declaration#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-cloneafter" class="doc_subtitle"><span class="doc_prefix">declaration#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-clonebefore" class="doc_subtitle"><span class="doc_prefix">declaration#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-error" class="doc_subtitle"><span class="doc_prefix">declaration#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="declaration-markdirty" class="doc_subtitle"><span class="doc_prefix">declaration#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="declaration-next" class="doc_subtitle"><span class="doc_prefix">declaration#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="declaration-parent" class="doc_subtitle"><span class="doc_prefix">declaration#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: <a href="#containerwithchildren">ContainerWithChildren</a>.</p><h2 id="declaration-positionby" class="doc_subtitle"><span class="doc_prefix">declaration#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="declaration-positioninside" class="doc_subtitle"><span class="doc_prefix">declaration#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="declaration-prev" class="doc_subtitle"><span class="doc_prefix">declaration#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="declaration-rangeby" class="doc_subtitle"><span class="doc_prefix">declaration#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="declaration-raw" class="doc_subtitle"><span class="doc_prefix">declaration#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="declaration-raws" class="doc_subtitle"><span class="doc_prefix">declaration#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: <a href="#declarationraws">DeclarationRaws</a>.</p><h2 id="declaration-remove" class="doc_subtitle"><span class="doc_prefix">declaration#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-replacewith" class="doc_subtitle"><span class="doc_prefix">declaration#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code>Declaration_</code>. </p><h2 id="declaration-root" class="doc_subtitle"><span class="doc_prefix">declaration#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="declaration-source" class="doc_subtitle"><span class="doc_prefix">declaration#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="declaration-tojson" class="doc_subtitle"><span class="doc_prefix">declaration#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="declaration-tostring" class="doc_subtitle"><span class="doc_prefix">declaration#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="declaration-type" class="doc_subtitle"><span class="doc_prefix">declaration#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "decl".</p><h2 id="declaration-warn" class="doc_subtitle"><span class="doc_prefix">declaration#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="document" class="doc_title">document</h1><h2 id="document-after" class="doc_subtitle"><span class="doc_prefix">document#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-append" class="doc_subtitle"><span class="doc_prefix">document#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">append</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-assign" class="doc_subtitle"><span class="doc_prefix">document#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object | <a href="#documentprops">DocumentProps</a></td><td>New properties to override the node.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-before" class="doc_subtitle"><span class="doc_prefix">document#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-cleanraws" class="doc_subtitle"><span class="doc_prefix">document#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="document-clone" class="doc_subtitle"><span class="doc_prefix">document#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#documentprops">DocumentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-cloneafter" class="doc_subtitle"><span class="doc_prefix">document#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#documentprops">DocumentProps</a>></td><td>New properties to override in the clone.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-clonebefore" class="doc_subtitle"><span class="doc_prefix">document#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#documentprops">DocumentProps</a>></td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-each" class="doc_subtitle"><span class="doc_prefix">document#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black; z-index: 1 }'</span>)
<span class="code-keyword">const</span> rule = root.<span class="code-property">first</span>

<span class="code-keyword">for</span> (<span class="code-keyword">const</span> decl <span class="code-keyword">of</span> rule.<span class="code-property">nodes</span>) {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code-comment">// to the next index</span>
}

rule.<span class="code-title function_">each</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> })
  <span class="code-comment">// Will be executed only for color and z-index</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-error" class="doc_subtitle"><span class="doc_prefix">document#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="document-every" class="doc_subtitle"><span class="doc_prefix">document#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> noPrefixes = rule.<span class="code-title function_">every</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] !== <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="document-index" class="doc_subtitle"><span class="doc_prefix">document#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">index</span>( rule.<span class="code-property">nodes</span>[<span class="code-number">2</span>] ) <span class="code-comment">//=> 2</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#root">Root</a></td><td>Child of the current container.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="document-insertafter" class="doc_subtitle"><span class="doc_prefix">document#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#root">Root</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-insertbefore" class="doc_subtitle"><span class="doc_prefix">document#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">insertBefore</span>(decl, decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-webkit-'</span> + decl.<span class="code-property">prop</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | <a href="#root">Root</a></td><td>Child or child’s index.</td></tr><tr><td><code>newNode</code></td><td><a href="#newchild">NewChild</a></td><td>New node.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-markdirty" class="doc_subtitle"><span class="doc_prefix">document#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="document-next" class="doc_subtitle"><span class="doc_prefix">document#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="document-nodes" class="doc_subtitle"><span class="doc_prefix">document#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { color: black }'</span>)
root.<span class="code-property">nodes</span>.<span class="code-property">length</span>           <span class="code-comment">//=> 1</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">selector</span>      <span class="code-comment">//=> 'a'</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">prop</span> <span class="code-comment">//=> 'color'</span>
</code></pre><p>Type: <a href="#root">Root</a>[].</p><h2 id="document-parent" class="doc_subtitle"><span class="doc_prefix">document#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: undefined.</p><h2 id="document-positionby" class="doc_subtitle"><span class="doc_prefix">document#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="document-positioninside" class="doc_subtitle"><span class="doc_prefix">document#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="document-prepend" class="doc_subtitle"><span class="doc_prefix">document#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> decl1 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
<span class="code-keyword">const</span> decl2 = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'background-color'</span>, <span class="code-attr">value</span>: <span class="code-string">'white'</span> })
rule.<span class="code-title function_">prepend</span>(decl1, decl2)

root.<span class="code-title function_">append</span>({ <span class="code-attr">name</span>: <span class="code-string">'charset'</span>, <span class="code-attr">params</span>: <span class="code-string">'"UTF-8"'</span> })  <span class="code-comment">// at-rule</span>
root.<span class="code-title function_">append</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> })                       <span class="code-comment">// rule</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })       <span class="code-comment">// declaration</span>
rule.<span class="code-title function_">append</span>({ <span class="code-attr">text</span>: <span class="code-string">'Comment'</span> })                     <span class="code-comment">// comment</span>

root.<span class="code-title function_">append</span>(<span class="code-string">'a {}'</span>)
root.<span class="code-property">first</span>.<span class="code-title function_">append</span>(<span class="code-string">'color: black; z-index: 1'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>New nodes.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-prev" class="doc_subtitle"><span class="doc_prefix">document#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="document-push" class="doc_subtitle"><span class="doc_prefix">document#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">push</span>(<span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> }))
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#root">Root</a></td><td>New node.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-rangeby" class="doc_subtitle"><span class="doc_prefix">document#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="document-raw" class="doc_subtitle"><span class="doc_prefix">document#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="document-raws" class="doc_subtitle"><span class="doc_prefix">document#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: any.</p><h2 id="document-remove" class="doc_subtitle"><span class="doc_prefix">document#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code>Document_</code>. </p><h2 id="document-removeall" class="doc_subtitle"><span class="doc_prefix">document#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code language-js">rule.<span class="code-title function_">removeAll</span>()
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span> <span class="code-comment">//=> 0</span>
</code></pre><p>Returns <code>Document_</code>. </p><h2 id="document-removechild" class="doc_subtitle"><span class="doc_prefix">document#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code language-js">rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 5</span>
rule.<span class="code-title function_">removeChild</span>(decl)
rule.<span class="code-property">nodes</span>.<span class="code-property">length</span>  <span class="code-comment">//=> 4</span>
decl.<span class="code-property">parent</span>        <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | <a href="#root">Root</a></td><td>Child or child’s index.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-replacevalues" class="doc_subtitle"><span class="doc_prefix">document#</span>replaceValues()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td></tr><tr><td><code>replaced</code></td><td>string | Function</td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td>Options to speed up the search.</td></tr><tr><td><code>replaced</code></td><td>string | Function</td><td>String to replace pattern or callback
that returns a new value. The callback
will receive the same arguments
as those passed to a function parameter
of <code>String#replace</code>.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-replacewith" class="doc_subtitle"><span class="doc_prefix">document#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code>Document_</code>. </p><h2 id="document-root" class="doc_subtitle"><span class="doc_prefix">document#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="document-some" class="doc_subtitle"><span class="doc_prefix">document#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> hasPrefix = rule.<span class="code-title function_">some</span>(<span class="code-function"><span class="code-params">i</span> =></span> i.<span class="code-property">prop</span>[<span class="code-number">0</span>] === <span class="code-string">'-'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>Function</td><td>Iterator returns true or false.</td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="document-source" class="doc_subtitle"><span class="doc_prefix">document#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="document-tojson" class="doc_subtitle"><span class="doc_prefix">document#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="document-toresult" class="doc_subtitle"><span class="doc_prefix">document#</span>toResult()</h2><p>Returns a <code><a href="#result">Result</a></code> instance representing the document’s CSS roots.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root1 = postcss.<span class="code-title function_">parse</span>(css1, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span> })
<span class="code-keyword">const</span> root2 = postcss.<span class="code-title function_">parse</span>(css2, { <span class="code-attr">from</span>: <span class="code-string">'b.css'</span> })
<span class="code-keyword">const</span> <span class="code-variable language_">document</span> = postcss.<span class="code-title function_">document</span>()
<span class="code-variable language_">document</span>.<span class="code-title function_">append</span>(root1)
<span class="code-variable language_">document</span>.<span class="code-title function_">append</span>(root2)
<span class="code-keyword">const</span> result = <span class="code-variable language_">document</span>.<span class="code-title function_">toResult</span>({ <span class="code-attr">to</span>: <span class="code-string">'all.css'</span>, <span class="code-attr">map</span>: <span class="code-literal">true</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a>&lt;Document_ | <a href="#root">Root</a>></td></tr></table><p>Returns <code><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></code>. </p><h2 id="document-tostring" class="doc_subtitle"><span class="doc_prefix">document#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="document-type" class="doc_subtitle"><span class="doc_prefix">document#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: "document".</p><h2 id="document-walk" class="doc_subtitle"><span class="doc_prefix">document#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walk</span>(<span class="code-function"><span class="code-params">node</span> =></span> {
  <span class="code-comment">// Traverses all descendant nodes.</span>
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkatrules" class="doc_subtitle"><span class="doc_prefix">document#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkAtRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (<span class="code-title function_">isOld</span>(rule.<span class="code-property">name</span>)) rule.<span class="code-title function_">remove</span>()
})

<span class="code-keyword">let</span> first = <span class="code-literal">false</span>
root.<span class="code-title function_">walkAtRules</span>(<span class="code-string">'charset'</span>, <span class="code-function"><span class="code-params">rule</span> =></span> {
  <span class="code-keyword">if</span> (!first) {
    first = <span class="code-literal">true</span>
  } <span class="code-keyword">else</span> {
    rule.<span class="code-title function_">remove</span>()
  }
})
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkcomments" class="doc_subtitle"><span class="doc_prefix">document#</span>walkComments()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>callback</code></td><td>Function</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkdecls" class="doc_subtitle"><span class="doc_prefix">document#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code language-js">root.<span class="code-title function_">walkDecls</span>(<span class="code-function"><span class="code-params">decl</span> =></span> {
  <span class="code-title function_">checkPropertySupport</span>(decl.<span class="code-property">prop</span>)
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-string">'border-radius'</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-title function_">remove</span>()
})

root.<span class="code-title function_">walkDecls</span>(<span class="code-regexp">/^background/</span>, <span class="code-function"><span class="code-params">decl</span> =></span> {
  decl.<span class="code-property">value</span> = <span class="code-title function_">takeFirstColorFromGradient</span>(decl.<span class="code-property">value</span>)
})
</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-walkrules" class="doc_subtitle"><span class="doc_prefix">document#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> selectors = []
root.<span class="code-title function_">walkRules</span>(<span class="code-function"><span class="code-params">rule</span> =></span> {
  selectors.<span class="code-title function_">push</span>(rule.<span class="code-property">selector</span>)
})
<span class="code-variable language_">console</span>.<span class="code-title function_">log</span>(<span class="code-string">`Your CSS uses <span class="code-subst">${ selectors.length }</span> selectors`</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>Function</td><td>Iterator receives each node and index.</td></tr></table><p>Returns <code>void | false</code>. </p><h2 id="document-warn" class="doc_subtitle"><span class="doc_prefix">document#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="fromjson" class="doc_title">fromJSON</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object[]</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p></section><section class="doc"><h1 id="input" class="doc_title">input</h1><h2 id="input-css" class="doc_subtitle"><span class="doc_prefix">input#</span>css</h2><p>Input CSS source.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> input = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{}'</span>, { <span class="code-attr">from</span>: file }).<span class="code-property">input</span>
input.<span class="code-property">css</span> <span class="code-comment">//=> "a{}"</span>
</code></pre><p>Type: string.</p><h2 id="input-document" class="doc_subtitle"><span class="doc_prefix">input#</span>document</h2><p>Input source with support for non-CSS documents.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> input = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a{}'</span>, { <span class="code-attr">from</span>: file, <span class="code-attr">document</span>: <span class="code-string">'&#x3C;style>a {}&#x3C;/style>'</span> }).<span class="code-property">input</span>
input.<span class="code-property">document</span> <span class="code-comment">//=> "&#x3C;style>a {}&#x3C;/style>"</span>
input.<span class="code-property">css</span> <span class="code-comment">//=> "a{}"</span>
</code></pre><p>Type: string.</p><h2 id="input-error" class="doc_subtitle"><span class="doc_prefix">input#</span>error()</h2><p>Returns <code><a href="#csssyntaxerror">CssSyntaxError</a></code> with information about the error and its position.</p><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>start</code></td><td>Object | Object</td></tr><tr><td><code>end</code></td><td>Object | Object</td></tr><tr><td><code>opts</code></td><td>Object</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>line</code></td><td>number</td></tr><tr><td><code>column</code></td><td>number</td></tr><tr><td><code>opts</code></td><td>Object</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>offset</code></td><td>number</td></tr><tr><td><code>opts</code></td><td>Object</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="input-file" class="doc_subtitle"><span class="doc_prefix">input#</span>file</h2><p>The absolute path to the CSS source file defined
with the <code>from</code> option.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(css, { <span class="code-attr">from</span>: <span class="code-string">'a.css'</span> })
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> '/home/ai/a.css'</span>
</code></pre><p>Type: string.</p><h2 id="input-fromlineandcolumn" class="doc_subtitle"><span class="doc_prefix">input#</span>fromLineAndColumn()</h2><p>Converts source line and column to offset.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>line</code></td><td>number</td><td>Source line.</td></tr><tr><td><code>column</code></td><td>number</td><td>Source column.</td></tr></table><p>Returns <code>number</code>. </p><h2 id="input-fromoffset" class="doc_subtitle"><span class="doc_prefix">input#</span>fromOffset()</h2><p>Converts source offset to line and column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>number</td><td>Source offset.</td></tr></table><p>Returns <code>Object</code>. </p><h2 id="input-hasbom" class="doc_subtitle"><span class="doc_prefix">input#</span>hasBOM</h2><p>The flag to indicate whether or not the source code has Unicode BOM.</p><p>Type: boolean.</p><h2 id="input-id" class="doc_subtitle"><span class="doc_prefix">input#</span>id</h2><p>The unique ID of the CSS source. It will be created if <code>from</code> option
is not provided (because PostCSS does not know the file path).</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(css)
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">file</span> <span class="code-comment">//=> undefined</span>
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">id</span>   <span class="code-comment">//=> "&#x3C;input css 8LZeVF>"</span>
</code></pre><p>Type: string.</p><h2 id="input-map" class="doc_subtitle"><span class="doc_prefix">input#</span>map</h2><p>The input source map passed from a compilation step before PostCSS
(for example, from Sass compiler).</p>
<pre><code class="code language-js">root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">map</span>.<span class="code-title function_">consumer</span>().<span class="code-property">sources</span> <span class="code-comment">//=> ['a.sass']</span>
</code></pre><p>Type: PreviousMap_.</p><h2 id="input-origin" class="doc_subtitle"><span class="doc_prefix">input#</span>origin()</h2><p>Reads the input source map and returns a symbol position
in the input source (e.g., in a Sass file that was compiled
to CSS before being passed to PostCSS). Optionally takes an
end position, exclusive.</p>
<pre><code class="code language-js">root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-title function_">origin</span>(<span class="code-number">1</span>, <span class="code-number">1</span>) <span class="code-comment">//=> { file: 'a.css', line: 3, column: 1 }</span>
root.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-title function_">origin</span>(<span class="code-number">1</span>, <span class="code-number">1</span>, <span class="code-number">1</span>, <span class="code-number">4</span>)
<span class="code-comment">//=> { file: 'a.css', line: 3, column: 1, endLine: 3, endColumn: 4 }</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>line</code></td><td>number</td><td>Line for inclusive start position in input CSS.</td></tr><tr><td><code>column</code></td><td>number</td><td>Column for inclusive start position in input CSS.</td></tr><tr><td><code>endLine</code></td><td>number</td><td>Line for exclusive end position in input CSS.</td></tr><tr><td><code>endColumn</code></td><td>number</td><td>Column for exclusive end position in input CSS.</td></tr></table><p>Returns <code>false | <a href="#fileposition">FilePosition</a></code>. </p><h2 id="input-tojson" class="doc_subtitle"><span class="doc_prefix">input#</span>toJSON()</h2><p>Converts this to a JSON-friendly object representation.</p><p>Returns <code>object</code>. </p></section><section class="doc"><h1 id="lazy-result" class="doc_title">lazy-result</h1><h2 id="lazy-result-async" class="doc_subtitle"><span class="doc_prefix">lazy-result#</span>async()</h2><p>Run plugin in async way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code>Promise&lt;<a href="#result">Result</a>&lt;RootNode>></code>. </p><h2 id="lazy-result-catch" class="doc_subtitle"><span class="doc_prefix">lazy-result#</span>catch</h2><p>Type: Function.</p><h2 id="lazy-result-finally" class="doc_subtitle"><span class="doc_prefix">lazy-result#</span>finally</h2><p>Type: Function.</p><h2 id="lazy-result-sync" class="doc_subtitle"><span class="doc_prefix">lazy-result#</span>sync()</h2><p>Run plugin in sync way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code><a href="#result">Result</a>&lt;RootNode></code>. </p><h2 id="lazy-result-then" class="doc_subtitle"><span class="doc_prefix">lazy-result#</span>then</h2><p>Type: Function.</p><h2 id="lazy-result-tostring" class="doc_subtitle"><span class="doc_prefix">lazy-result#</span>toString()</h2><p>Alias for the <code><a href="#lazyresult-css">LazyResult#css</a></code> property.</p>
<pre><code class="code language-js">lazy + <span class="code-string">''</span> === lazy.<span class="code-property">css</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="lazy-result-warnings" class="doc_subtitle"><span class="doc_prefix">lazy-result#</span>warnings()</h2><p>Processes input CSS through synchronous plugins
and calls <code><a href="#result-warnings">Result#warnings</a></code>.</p><p>Returns <code><a href="#warning">Warning</a>[]</code>. </p></section><section class="doc"><h1 id="no-work-result" class="doc_title">no-work-result</h1><h2 id="no-work-result-async" class="doc_subtitle"><span class="doc_prefix">no-work-result#</span>async()</h2><p>Run plugin in async way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code>Promise&lt;<a href="#result">Result</a>&lt;<a href="#root">Root</a>>></code>. </p><h2 id="no-work-result-catch" class="doc_subtitle"><span class="doc_prefix">no-work-result#</span>catch</h2><p>Type: Function.</p><h2 id="no-work-result-finally" class="doc_subtitle"><span class="doc_prefix">no-work-result#</span>finally</h2><p>Type: Function.</p><h2 id="no-work-result-sync" class="doc_subtitle"><span class="doc_prefix">no-work-result#</span>sync()</h2><p>Run plugin in sync way and return <code><a href="#result">Result</a></code>.</p><p>Returns <code><a href="#result">Result</a>&lt;<a href="#root">Root</a>></code>. </p><h2 id="no-work-result-then" class="doc_subtitle"><span class="doc_prefix">no-work-result#</span>then</h2><p>Type: Function.</p><h2 id="no-work-result-tostring" class="doc_subtitle"><span class="doc_prefix">no-work-result#</span>toString()</h2><p>Alias for the <code><a href="#lazyresult-css">LazyResult#css</a></code> property.</p>
<pre><code class="code language-js">lazy + <span class="code-string">''</span> === lazy.<span class="code-property">css</span>
</code></pre><p>Returns <code>string</code>. </p><h2 id="no-work-result-warnings" class="doc_subtitle"><span class="doc_prefix">no-work-result#</span>warnings()</h2><p>Processes input CSS through synchronous plugins
and calls <code><a href="#result-warnings">Result#warnings</a></code>.</p><p>Returns <code><a href="#warning">Warning</a>[]</code>. </p></section><section class="doc"><h1 id="node" class="doc_title">node</h1><h2 id="node-after" class="doc_subtitle"><span class="doc_prefix">node#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">after</span>(<span class="code-string">'color: black'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-assign" class="doc_subtitle"><span class="doc_prefix">node#</span>assign()</h2><p>It assigns properties to an existing node instance.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">assign</span>({ <span class="code-attr">prop</span>: <span class="code-string">'word-wrap'</span>, <span class="code-attr">value</span>: <span class="code-string">'break-word'</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override the node.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-before" class="doc_subtitle"><span class="doc_prefix">node#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">before</span>(<span class="code-string">'content: ""'</span>)
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#node">Node</a> | <a href="#childprops">ChildProps</a> | readonly <a href="#node">Node</a>[]</td><td>New node.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-cleanraws" class="doc_subtitle"><span class="doc_prefix">node#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code language-js">node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> ' '</span>
node.<span class="code-title function_">cleanRaws</span>()
node.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> undefined</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.</td></tr></table><h2 id="node-clone" class="doc_subtitle"><span class="doc_prefix">node#</span>clone()</h2><p>It creates clone of an existing node, which includes all the properties
and their values, that includes <code>raws</code> but not <code>type</code>.</p>
<pre><code class="code language-js">decl.<span class="code-property">raws</span>.<span class="code-property">before</span>    <span class="code-comment">//=> "\n  "</span>
<span class="code-keyword">const</span> cloned = decl.<span class="code-title function_">clone</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
cloned.<span class="code-property">raws</span>.<span class="code-property">before</span>  <span class="code-comment">//=> "\n  "</span>
cloned.<span class="code-title function_">toString</span>()   <span class="code-comment">//=> -moz-transform: scale(0)</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-cloneafter" class="doc_subtitle"><span class="doc_prefix">node#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-clonebefore" class="doc_subtitle"><span class="doc_prefix">node#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code language-js">decl.<span class="code-title function_">cloneBefore</span>({ <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span> })
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>Mew properties to override in the clone.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-error" class="doc_subtitle"><span class="doc_prefix">node#</span>error()</h2><p>It creates an instance of the class <code><a href="#csssyntaxerror">CssSyntaxError</a></code> and parameters passed
to this method are assigned to the error instance.</p>
<p>The error instance will have description for the
error, original position of the node in the
source, showing line and column number.</p>
<p>If any previous map is present, it would be used
to get original position of the source.</p>
<p>The Previous Map here is referred to the source map
generated by previous compilation, example: Less,
Stylus and Sass.</p>
<p>This method returns the error instance instead of
throwing it.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (!variables[name]) {
  <span class="code-keyword">throw</span> decl.<span class="code-title function_">error</span>(<span class="code-string">`Unknown variable <span class="code-subst">${name}</span>`</span>, { <span class="code-attr">word</span>: name })
  <span class="code-comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code-comment">//   color: $black</span>
  <span class="code-comment">// a</span>
  <span class="code-comment">//          ^</span>
  <span class="code-comment">//   background: white</span>
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Description for the error instance.</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td>Options for the error instance.</td></tr></table><p>Returns <code>CssSyntaxError_</code>. </p><h2 id="node-markdirty" class="doc_subtitle"><span class="doc_prefix">node#</span>markDirty()</h2><p>If this node isn't already dirty, marks it and its ancestors as such. This
indicates to the LazyResult processor that the Root has been
modified by the current plugin and may need to be processed again by other
plugins.</p><h2 id="node-next" class="doc_subtitle"><span class="doc_prefix">node#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (comment.<span class="code-property">text</span> === <span class="code-string">'delete next'</span>) {
  <span class="code-keyword">const</span> next = comment.<span class="code-title function_">next</span>()
  <span class="code-keyword">if</span> (next) {
    next.<span class="code-title function_">remove</span>()
  }
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="node-parent" class="doc_subtitle"><span class="doc_prefix">node#</span>parent</h2><p>It represents parent of the current node.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">parent</span> === root <span class="code-comment">//=> true</span>
</code></pre><p>Type: Container_&lt;<a href="#childnode">ChildNode</a>> | Document_.</p><h2 id="node-positionby" class="doc_subtitle"><span class="doc_prefix">node#</span>positionBy()</h2><p>Get the position for a word or an index inside the node.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "word"></td><td>Options.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="node-positioninside" class="doc_subtitle"><span class="doc_prefix">node#</span>positionInside()</h2><p>Convert string index to line/column.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. </p><h2 id="node-prev" class="doc_subtitle"><span class="doc_prefix">node#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> annotation = decl.<span class="code-title function_">prev</span>()
<span class="code-keyword">if</span> (annotation.<span class="code-property">type</span> === <span class="code-string">'comment'</span>) {
  <span class="code-title function_">readAnnotation</span>(annotation.<span class="code-property">text</span>)
}
</code></pre><p>Returns <code><a href="#childnode">ChildNode</a></code>. </p><h2 id="node-rangeby" class="doc_subtitle"><span class="doc_prefix">node#</span>rangeBy()</h2><p>Get the range for a word or start and end index inside the node.
The start index is inclusive; the end index is exclusive.</p><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#warningoptions">WarningOptions</a>, "index" | "end" | "start" | "word" | "endIndex"></td><td>Options.</td></tr></table><p>Returns <code><a href="#range">Range</a></code>. </p><h2 id="node-raw" class="doc_subtitle"><span class="doc_prefix">node#</span>raw()</h2><p>Returns a <code>raws</code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a { background: white }'</span>)
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">append</span>({ <span class="code-attr">prop</span>: <span class="code-string">'color'</span>, <span class="code-attr">value</span>: <span class="code-string">'black'</span> })
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-property">raws</span>.<span class="code-property">before</span>   <span class="code-comment">//=> undefined</span>
root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">1</span>].<span class="code-title function_">raw</span>(<span class="code-string">'before'</span>) <span class="code-comment">//=> ' '</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="node-raws" class="doc_subtitle"><span class="doc_prefix">node#</span>raws</h2><p>It represents unnecessary whitespace and characters present
in the css source code.</p>
<p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>The properties of the raws object are decided by parser,
the default parser uses the following properties:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and */.</li>
</ul>
<ul>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS filters out the comments inside selectors, declaration values
and at-rule parameters but it stores the origin content in raws.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> root = postcss.<span class="code-title function_">parse</span>(<span class="code-string">'a {\n  color:black\n}'</span>)
root.<span class="code-property">first</span>.<span class="code-property">first</span>.<span class="code-property">raws</span> <span class="code-comment">//=> { before: '\n  ', between: ':' }</span>
</code></pre><p>Type: any.</p><h2 id="node-remove" class="doc_subtitle"><span class="doc_prefix">node#</span>remove()</h2><p>It removes the node from its parent and deletes its parent property.</p>
<pre><code class="code language-js"><span class="code-keyword">if</span> (decl.<span class="code-property">prop</span>.<span class="code-title function_">match</span>(<span class="code-regexp">/^-webkit-/</span>)) {
  decl.<span class="code-title function_">remove</span>()
}
</code></pre><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-replacewith" class="doc_subtitle"><span class="doc_prefix">node#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code language-js"><span class="code-title class_">AtRule</span>: {
  <span class="code-attr">mixin</span>: <span class="code-function"><span class="code-params">atrule</span> =></span> {
    atrule.<span class="code-title function_">replaceWith</span>(mixinRules[atrule.<span class="code-property">params</span>])
  }
}
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td><a href="#newchild">NewChild</a>[]</td><td>Mode(s) to replace current one.</td></tr></table><p>Returns <code><a href="#node">Node</a></code>. </p><h2 id="node-root" class="doc_subtitle"><span class="doc_prefix">node#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code language-js">root.<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-property">nodes</span>[<span class="code-number">0</span>].<span class="code-title function_">root</span>() === root
</code></pre><p>Returns <code><a href="#root">Root</a></code>. </p><h2 id="node-source" class="doc_subtitle"><span class="doc_prefix">node#</span>source</h2><p>It represents information related to origin of a node and is required
for generating source maps.</p>
<p>The nodes that are created manually using the public APIs
provided by PostCSS will have <code>source</code> undefined and
will be absent in the source map.</p>
<p>For this reason, the plugin developer should consider
duplicating nodes as the duplicate node will have the
same source as the original node by default or assign
source to a node created manually.</p>
<pre><code class="code language-js">decl.<span class="code-property">source</span>.<span class="code-property">input</span>.<span class="code-property">from</span> <span class="code-comment">//=> '/home/ai/source.css'</span>
decl.<span class="code-property">source</span>.<span class="code-property">start</span>      <span class="code-comment">//=> { line: 10, column: 2 }</span>
decl.<span class="code-property">source</span>.<span class="code-property">end</span>        <span class="code-comment">//=> { line: 10, column: 12 }</span>
</code></pre>
<pre><code class="code language-js"><span class="code-comment">// Incorrect method, source not specified!</span>
<span class="code-keyword">const</span> prefixed = postcss.<span class="code-title function_">decl</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>,
  <span class="code-attr">value</span>: decl.<span class="code-property">value</span>
})

<span class="code-comment">// Correct method, source is inherited when duplicating.</span>
<span class="code-keyword">const</span> prefixed = decl.<span class="code-title function_">clone</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'-moz-'</span> + decl.<span class="code-property">prop</span>
})
</code></pre>
<pre><code class="code language-js"><span class="code-keyword">if</span> (atrule.<span class="code-property">name</span> === <span class="code-string">'add-link'</span>) {
  <span class="code-keyword">const</span> rule = postcss.<span class="code-title function_">rule</span>({
    <span class="code-attr">selector</span>: <span class="code-string">'a'</span>,
    <span class="code-attr">source</span>: atrule.<span class="code-property">source</span>
  })

 atrule.<span class="code-property">parent</span>.<span class="code-title function_">insertBefore</span>(atrule, rule)
}
</code></pre><p>Type: <a href="#source">Source</a>.</p><h2 id="node-tojson" class="doc_subtitle"><span class="doc_prefix">node#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p><p>Returns <code>object</code>. </p><h2 id="node-tostring" class="doc_subtitle"><span class="doc_prefix">node#</span>toString()</h2><p>It compiles the node to browser readable cascading style sheets string
depending on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">new</span> <span class="code-title class_">Rule</span>({ <span class="code-attr">selector</span>: <span class="code-string">'a'</span> }).<span class="code-title function_">toString</span>() <span class="code-comment">//=> "a {}"</span>
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a>&lt;Document_ | <a href="#root">Root</a>></td><td>A syntax to use in string generation.</td></tr></table><p>Returns <code>string</code>. </p><h2 id="node-type" class="doc_subtitle"><span class="doc_prefix">node#</span>type</h2><p>It represents type of a node in
an abstract syntax tree.</p>
<p>A type of node helps in identification of a node
and perform operation based on it's type.</p>
<pre><code class="code language-js"><span class="code-keyword">const</span> declaration = <span class="code-keyword">new</span> <span class="code-title class_">Declaration</span>({
  <span class="code-attr">prop</span>: <span class="code-string">'color'</span>,
  <span class="code-attr">value</span>: <span class="code-string">'black'</span>
})

declaration.<span class="code-property">type</span> <span class="code-comment">//=> 'decl'</span>
</code></pre><p>Type: string.</p><h2 id="node-warn" class="doc_subtitle"><span class="doc_prefix">node#</span>warn()</h2><p>It is a wrapper for Result#warn, providing convenient
way of generating warnings.</p>
<pre><code class="code language-js">  <span class="code-title class_">Declaration</span>: {
    <span class="code-attr">bad</span>: <span class="code-function">(<span class="code-params">decl, { result }</span>) =></span> {
      decl.<span class="code-title function_">warn</span>(result, <span class="code-string">'Deprecated property: bad'</span>)
    }
  }
</code></pre><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td><a href="#result">Result</a>&lt;Document_ | <a href="#root">Root</a>></td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.</td></tr><tr><td><code>message</code></td><td>string</td><td>Description for the warning.</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Options for the warning.</td></tr></table><p>Returns <code><a href="#warning">Warning</a></code>. </p></section><section class="doc"><h1 id="previous-map" class="doc_title">previous-map</h1><h2 id="previous-map-annotation" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>annotation</h2><p><code>sourceMappingURL</code> content.</p><p>Type: string.</p><h2 id="previous-map-consumer" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>consumer()</h2><p>Create a instance of <code>SourceMapGenerator</code> class
from the <code>source-map</code> library to work with source map information.</p>
<p>It is lazy method, so it will create object only on first call
and then it will use cache.</p><p>Returns <code>SourceMapConsumer</code>. </p><h2 id="previous-map-file" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>file</h2><p>The CSS source identifier. Contains <code><a href="#input-file">Input#file</a></code> if the user
set the <code>from</code> option, or <code><a href="#input-id">Input#id</a></code> if they did not.</p><p>Type: string.</p><h2 id="previous-map-inline" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>inline</h2><p>Was source map inlined by data-uri to input CSS.</p><p>Type: boolean.</p><h2 id="previous-map-mapfile" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>mapFile</h2><p>Path to source map file.</p><p>Type: string.</p><h2 id="previous-map-root" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>root</h2><p>The directory with source map file, if source map is in separated file.</p><p>Type: string.</p><h2 id="previous-map-text" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>text</h2><p>Source map file content.</p><p>Type: string.</p><h2 id="previous-map-withcontent" class="doc_subtitle"><span class="doc_prefix">previous-map#</span>withContent()</h2><p>Does source map contains <code>sourcesContent</code> with input source text.</p><p>Returns <code>boolean</code>. </p></section><section class="doc"><h1 id="stringifier" class="doc_title">stringifier</h1><h2 id="stringifier-atrule" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>atrule()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>AtRule_</td></tr><tr><td><code>semicolon</code></td><td>boolean</td></tr></table><h2 id="stringifier-beforeafter" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>beforeAfter()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>detect</code></td><td>"after" | "before"</td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-block" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>block()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>start</code></td><td>string</td></tr></table><h2 id="stringifier-body" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>body()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Container_&lt;<a href="#childnode">ChildNode</a>></td></tr></table><h2 id="stringifier-builder" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>builder</h2><p>Type: <a href="#builder">Builder</a>.</p><h2 id="stringifier-comment" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>comment()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Comment_</td></tr></table><h2 id="stringifier-decl" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>decl()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Declaration_</td></tr><tr><td><code>semicolon</code></td><td>boolean</td></tr></table><h2 id="stringifier-document" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>document()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td>Document_</td></tr></table><h2 id="stringifier-raw" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>raw()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>own</code></td><td>string</td></tr><tr><td><code>detect</code></td><td>string</td></tr></table><p>Returns <code>string | boolean</code>. </p><h2 id="stringifier-rawbeforeclose" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawBeforeClose()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforecomment" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawBeforeComment()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>node</code></td><td>Comment_</td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforedecl" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawBeforeDecl()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr><tr><td><code>node</code></td><td>Declaration_</td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforeopen" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawBeforeOpen()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawbeforerule" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawBeforeRule()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawcolon" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawColon()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawemptybody" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawEmptyBody()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawindent" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawIndent()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>string</code>. </p><h2 id="stringifier-rawsemicolon" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawSemicolon()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td><a href="#root">Root</a></td></tr></table><p>Returns <code>boolean</code>. </p><h2 id="stringifier-rawvalue" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rawValue()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>prop</code></td><td>string</td></tr></table><p>Returns <code>string | number</code>. </p><h2 id="stringifier-root" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>root()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#root">Root</a></td></tr></table><h2 id="stringifier-rule" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>rule()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#rule">Rule</a></td></tr></table><h2 id="stringifier-stringify" class="doc_subtitle"><span class="doc_prefix">stringifier#</span>stringify()</h2><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>semicolon</code></td><td>boolean</td></tr></table></section><aside class="socials"><ul class="socials_items"><li class="socials_item"><a class="socials_link is-open-collective" href="https://opencollective.com/postcss/" rel="me">Open Collective</a></li><li class="socials_item"><a class="socials_link is-twitter" href="https://twitter.com/postcss" rel="me">Twitter</a></li><li class="socials_item"><a class="socials_link is-github" href="https://github.com/postcss/postcss" rel="me">GitHub</a></li></ul></aside><footer class="footer"><div class="footer_inner"><div class="footer_info"><p class="footer_license">Distributed under the MIT License.</p><p class="footer_issue">Found an issue?<a class="footer_report" href="https://github.com/postcss/postcss.org/issues">Report it!</a></p></div><div><a href="https://evilmartians.com/?utm_source=postcss&amp;utm_campaign=homepage"><img alt="Evil Martians" src="/api/assets/evilmartians-bzYkprTm.svg"></a></div></div></footer></main></body></html>
